/* Copyright 2008 Combined Conditional Access Development, LLC. */
package com.ccadllc.firebird.dss.it;

import static com.ccadllc.commons.util.MoreHamcrest.waitUntil;
import static com.ccadllc.firebird.dss.common.datatypes.RouteDataType.BLOCKS;
import static com.ccadllc.firebird.dss.common.datatypes.RouteDataType.MPEG_PACKETS;
import static com.ccadllc.firebird.dss.it.MxBeanUtils.verifyMBeanUnregistered;
import static com.ccadllc.firebird.dss.it.RemoteMessageUtility.asMessageObject;
import static com.ccadllc.firebird.dss.it.RemoteMessageUtility.asXml;
import static com.ccadllc.firebird.dss.server.common.RouteJmxUtility.ROUTE_DESCRIPTOR_TEMPLATE;
import static com.google.common.collect.Lists.newArrayList;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.is;
import static org.hamcrest.Matchers.not;
import static org.hamcrest.Matchers.notNullValue;
import static org.junit.Assert.fail;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.Socket;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeoutException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.management.MBeanServer;
import javax.management.ObjectName;
import javax.management.openmbean.CompositeDataSupport;
import javax.management.openmbean.TabularDataSupport;
import javax.xml.bind.JAXBException;

import com.ccadllc.commons.io.BitInputStream;
import com.ccadllc.commons.io.Crc;
import com.ccadllc.commons.util.MapUtility;
import com.ccadllc.commons.util.MoreHamcrest;
import com.ccadllc.firebird.core.test.appsvr.WebHelper;
import com.ccadllc.firebird.core.test.appsvr.support.AbstractApplicationServerTest;
import com.ccadllc.firebird.dss.common.datatypes.RouteDataType;
import com.ccadllc.firebird.dss.common.datatypes.RouteType;
import com.ccadllc.firebird.dss.common.datatypes.StreamSummary;
import com.ccadllc.firebird.dss.common.datatypes.TransportProtocolType;
import com.ccadllc.firebird.dss.common.remote.messages.AddAncillaryStreamRequest;
import com.ccadllc.firebird.dss.common.remote.messages.AddBlockSetRequest;
import com.ccadllc.firebird.dss.common.remote.messages.AddBlockSetResponse;
import com.ccadllc.firebird.dss.common.remote.messages.AddComponentStreamRequest;
import com.ccadllc.firebird.dss.common.remote.messages.BlockDescriptor;
import com.ccadllc.firebird.dss.common.remote.messages.BlockSetDescriptor;
import com.ccadllc.firebird.dss.common.remote.messages.CreateIpDirectTransportStreamRequest;
import com.ccadllc.firebird.dss.common.remote.messages.CreateMpeg2TransportStreamRequest;
import com.ccadllc.firebird.dss.common.remote.messages.CreateShaperRequest;
import com.ccadllc.firebird.dss.common.remote.messages.CreateStandaloneStreamRequest;
import com.ccadllc.firebird.dss.common.remote.messages.CreateStandaloneStreamResponse;
import com.ccadllc.firebird.dss.common.remote.messages.DeleteProgramRequest;
import com.ccadllc.firebird.dss.common.remote.messages.DestinationInfo;
import com.ccadllc.firebird.dss.common.remote.messages.ElementaryStreams;
import com.ccadllc.firebird.dss.common.remote.messages.ErrorResponse;
import com.ccadllc.firebird.dss.common.remote.messages.EstablishRouteRequest;
import com.ccadllc.firebird.dss.common.remote.messages.IntegerRangeSummary;
import com.ccadllc.firebird.dss.common.remote.messages.MeteringType;
import com.ccadllc.firebird.dss.common.remote.messages.OkResponse;
import com.ccadllc.firebird.dss.common.remote.messages.PidMapped;
import com.ccadllc.firebird.dss.common.remote.messages.PidMapping;
import com.ccadllc.firebird.dss.common.remote.messages.QueryForUdpRoutesRequest;
import com.ccadllc.firebird.dss.common.remote.messages.QueryForUdpRoutesResponse;
import com.ccadllc.firebird.dss.common.remote.messages.StreamDestinationInfo;
import com.ccadllc.firebird.dss.common.remote.messages.TcpRoute;
import com.ccadllc.firebird.dss.common.remote.messages.TransmissionType;
import com.ccadllc.firebird.dss.common.remote.messages.TransportStreams;
import com.ccadllc.firebird.dss.common.remote.messages.UdpRoute;
import com.ccadllc.firebird.dss.common.remote.messages.UdpRouteSummary;
import com.ccadllc.firebird.dss.common.remote.messages.UpdateIpDirectTransportStreamDestinationsRequest;
import com.ccadllc.firebird.dss.common.remote.messages.UpdateMpeg2TransportStreamDestinationsRequest;
import com.ccadllc.firebird.dss.common.remote.messages.UpdateProgramRequest;
import com.ccadllc.firebird.dss.common.remote.messages.UpdateShaperRequest;
import com.ccadllc.firebird.dss.common.remote.messages.UpdateStandaloneStreamDestinationsRequest;
import com.ccadllc.firebird.dss.common.remote.messages.UpdateStreamShapingPolicyRequest;
import com.ccadllc.firebird.dss.common.remote.messages.UpdateTransportStreamPropertiesRequest;
import com.ccadllc.firebird.dss.common.remote.messages.UpdateTransportStreamShapingPolicyRequest;
import com.ccadllc.firebird.dss.server.common.PeriodicDataType;
import com.ccadllc.firebird.dss.server.common.RouteJmxUtility;
import com.ccadllc.firebird.dss.server.common.blocks.JRubyBlockGenerator;
import com.ccadllc.firebird.dss.server.provisioning.remote.messaging.handler.MeteringTypeTransformer;
import com.ccadllc.firebird.dss.server.realtime.common.Events;
import com.ccadllc.firebird.dss.server.realtime.snapshot.manager.RealTimeSnapshotManager;
import com.ccadllc.firebird.vms.common.mpeg2.psi.AbstractMpegDescriptor;
import com.ccadllc.firebird.vms.common.mpeg2.psi.MpegCurrentNextIndicator;
import com.ccadllc.firebird.vms.common.mpeg2.psi.ProgramDefinition;
import com.ccadllc.firebird.vms.common.mpeg2.psi.ProgramElement;
import com.ccadllc.firebird.vms.common.mpeg2.psi.ProgramPidMapping;
import com.ccadllc.firebird.vms.common.mpeg2.psi.PsiMessageGenerator;
import com.ccadllc.firebird.vms.common.units.TrafficShapingProfile;

import org.apache.commons.httpclient.HttpClient;
import org.apache.commons.httpclient.methods.InputStreamRequestEntity;
import org.apache.commons.httpclient.methods.PutMethod;
import org.apache.commons.lang.ArrayUtils;
import org.apache.commons.lang.StringUtils;
import org.hamcrest.BaseMatcher;
import org.hamcrest.Description;
import org.hamcrest.TypeSafeMatcher;
import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.osgi.framework.Bundle;
import org.osgi.framework.BundleException;
import org.osgi.service.event.Event;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.osgi.extensions.annotation.ServiceReference;

import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;

/** Convenience base class for writing integration tests for DSS bundles. */
public abstract class AbstractDssOsgiIntegrationTest extends AbstractApplicationServerTest
{
    public static final int MAX_PID = 8191;
    public static final int MIN_PID = 0;
    public static final int MAX_UDP_PORT_NUMBER = 65535;
    public static final int MIN_UDP_PORT_NUMBER = 1024;
    public static final String IP_STRING = "127.0.0.1";
    public static final String IP_STRING2 = "127.0.0.2";
    public static final String IP_STRING3 = "127.0.0.3";
    public static final int TRANSPORT_STREAM_ID = 123;
    public static final String CONFIGURATION_CHANGED_EVENT = "org/osgi/service/cm/ConfigurationEvent/CM_UPDATED";
    public static final String ROUTE_LISTENING_EVENT = com.ccadllc.firebird.dss.server.realtime.common.Events.ESTABLISH_EXTERNAL_ROUTE_EVENT; // TODO
    public static final String[] EVENT_TOPICS = new String[] {CONFIGURATION_CHANGED_EVENT, Events.ESTABLISH_EXTERNAL_ROUTE_EVENT,
        Events.REMOVE_EXTERNAL_ROUTE_EVENT, Events.UPDATE_EXTERNAL_ROUTE_EVENT, RealTimeSnapshotManager.STREAM_SNAPSHOT_UPDATED_EVENT, RealTimeSnapshotManager.TRANSPORT_STREAM_UPDATED_EVENT};
    public static final int PORT1 = System.getProperty("dssit.datagram.socket.port1") == null ? 5006 : Integer.parseInt(System
        .getProperty("dssit.datagram.socket.port1"));
    public static final int PORT2 = System.getProperty("dssit.datagram.socket.port2") == null ? 5007 : Integer.parseInt(System
        .getProperty("dssit.datagram.socket.port2"));
    public static final int PORT3 = System.getProperty("dssit.datagram.socket.port3") == null ? 5008 : Integer.parseInt(System
        .getProperty("dssit.datagram.socket.port3"));
    public static final int PORT4 = System.getProperty("dssit.datagram.socket.port4") == null ? 5009 : Integer.parseInt(System
        .getProperty("dssit.datagram.socket.port4"));
    public static final byte TEST_BLOCK_DATA_VALUE = (byte)0x64;
    public static final int MPEG_PADDING_BYTE = 0xFF;
    public static final int MPEG_PACKET_SIZE = 188;
    public static final List<AbstractMpegDescriptor> EMPTY_MPEG_DESCRIPTOR = newArrayList();

    // TODO this is also in StubDssOutputHandler
    public static final int MAX_BUFFER_VALUE = 1024;

    /** MPEG Packet Size minus header of 4 bytes. */
    public static final int MPEG_PACKET_PAYLOAD_SIZE = 184;

    /** The first MPEG Packet in a series needs to have a one byte start indicator. */
    public static final int MPEG_PACKET_PAYLOAD_SIZE_FOR_FIRST_IN_SERIES = 183;

    public static final int MAX_MPEG_PACKETS_IN_UDP_DATAGRAM = 7;
    public static final int MAX_AVERAGE = 50000;
    public static final int MAX_BURST = 2444;
    public static final int MAX_LATENCY = 60;
    public static final int PID_MINIMUM = 0;
    public static final int PID_OUT1 = 1234;
    public static final int PID_OUT2 = 1235;
    public static final int VALID_PID = 0x1503;
    public static final int VALID_PID2 = 0x1504;

    // Maximum is 13 bit integer (2^13-1)
    public static final int PID_MAXIMUM = 8191;
    public static final long SHAPING_PARAM_TOO_LARGE_VALUE = 2147483648L;
    public static final byte[] CONTENTS_OF_BLOCKSET = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09};
    public static final int NUMBER_OF_BLOCKS = 2;
    public static final int SIZE_OF_BLOCK = 5;

    public static final StreamDestinationInfo DESTINATION1 = new StreamDestinationInfo(IP_STRING, PORT1);
    public static final StreamDestinationInfo DESTINATION2 = new StreamDestinationInfo(IP_STRING, PORT2);
    public static final List<StreamDestinationInfo> TS_DESTINATION = Lists.newArrayList(new StreamDestinationInfo(IP_STRING, PORT1));
    protected static Integer nextValidPid = 0;
    protected static final String SNAPSHOT_BUNDLE = "com.ccadllc.firebird.dss.server.realtime.snapshot.manager";
    protected static final String MXBEAN_PROPERTIES_KEY = "Properties";
    protected static final String PERIODIC_PROPERTIES_KEY = "message-type";
    protected static final String PERIODIC_PROPERTIES_VALUE = "cvt";
    protected static final String SHAPER_PROPERTIES_KEY = "hello";
    protected static final String SHAPER_PROPERTIES_VALUE = "world";
    protected static final String STREAM_PROPERTIES_KEY = "dta.key";
    protected static final String STREAM_PROPERTIES_VALUE = "network.stream";
    protected static final String TRANSPORT_STREAM_PROPERTIES_KEY = "stream.name";
    protected static final String TRANSPORT_STREAM_PROPERTIES_VALUE = "transport stream";
    protected static final String ROUTE_PROPERTIES_KEY = "name";
    protected static final String ROUTE_PROPERTIES_VALUE = "my route";

    @SuppressWarnings("unused")
    private static final MeteringType METERING_TYPE = MeteringType.EVENLY_SPACED;

    private static final Logger logger = LoggerFactory.getLogger(AbstractDssOsgiIntegrationTest.class);

    public final List<IntegerRangeSummary> reservedPidRanges = Lists.newArrayList(new IntegerRangeSummary(1, 2));
    public final List<IntegerRangeSummary> reservedProgramNumberRange = Lists.newArrayList(new IntegerRangeSummary(4, 5));

    public final Map<String, String> streamProperties = Collections.unmodifiableMap(MapUtility.<String, String>toMap(STREAM_PROPERTIES_KEY, STREAM_PROPERTIES_VALUE));
    public final Map<String, String> periodicProperties = Collections.unmodifiableMap(MapUtility.<String, String>toMap(PERIODIC_PROPERTIES_KEY, PERIODIC_PROPERTIES_VALUE));
    public final Map<String, String> routeProperties = Collections.unmodifiableMap(MapUtility.<String, String>toMap(ROUTE_PROPERTIES_KEY, ROUTE_PROPERTIES_VALUE));
    public final Map<String, String> blockSetProperties = Collections.unmodifiableMap(MapUtility.<String, String>toMap("blockSetKey1", "blockSetValue1", "blockSetKey2", "blockSetValue2"));
    public final Map<String, String> transportStreamProperties = Collections.unmodifiableMap(MapUtility.<String, String>toMap("createTSKey", "createTSValue"));
    public final Map<String, String> programProperties = Collections.unmodifiableMap(MapUtility.<String, String>toMap("programKey1", "programValue1", "programKey2", "programValue2"));
    public final Map<String, String> componentStreamProperties = Collections.unmodifiableMap(MapUtility.<String, String>toMap("compKey1", "compValue1", "compKey2", "compValue2"));
    public final Map<String, String> ancillaryStreamProperties = Collections.unmodifiableMap(MapUtility.<String, String>toMap("ancKey1", "ancValue1", "ancKey2", "ancValue2"));
    public final Map<String, String> shaperProperties = Collections.unmodifiableMap(MapUtility.<String, String>toMap(SHAPER_PROPERTIES_KEY, SHAPER_PROPERTIES_VALUE));

    @Autowired
    protected JdbcTemplate jdbcTemplate;

    @Autowired
    protected PsiMessageGenerator psiMessageGenerator;

    protected StubDssOutputHandler outputHandler;
    protected StubDssClient dssClient;
    protected RouteTestUtility routeTestUtility;
    protected RouteClientUtility routeClientUtility;

    @Autowired
    private EventBucket eventBucket;

    private WebHelper webHelper;

    @ServiceReference public void setWebHelper(final WebHelper webHelper)
    {
        this.webHelper = webHelper;
    }

    @Before public void onSetUp() throws Exception
    {
        logger.debug("-------------------- Setting up test -------------------");
        clearExistingModelChangeEvents();
        dssClient = new StubDssClient();
        outputHandler = new StubDssOutputHandler();
        routeTestUtility = RouteTestUtility.instance();
        routeClientUtility = RouteClientUtility.instance();
        webHelper.waitForUrlAvailability("/dss/requests/");
    }

    @After public void onTearDown() throws Exception
    {
        logger.debug("-------------------- Tearing down test -------------------");
        eventBucket.clearEvents();

        for (final Long periodicId : dssClient.getAllPeriodicIds())
        {
            deletePeriodic(periodicId);
        }
        for (final Long routeId : dssClient.getAllRouteIds())
        {
            dssClient.removeRoute(routeId);
        }
        for (final int transportStreamId : dssClient.getAllTransportStreamIds())
        {
            dssClient.deleteTransportStream(transportStreamId);
        }
        for (final Long shaperId : dssClient.getAllShaperIds())
        {
            deleteShaper(shaperId);
        }
        for (final Long blockSetId : dssClient.getAllBlockSetIds())
        {
            dssClient.deleteBlockSet(blockSetId);
        }

        jdbcTemplate.execute("DELETE FROM periodic_property");
        jdbcTemplate.execute("DELETE FROM periodic");
        jdbcTemplate.execute("DELETE FROM stream_property");
        jdbcTemplate.execute("DELETE FROM stream_destination");
        jdbcTemplate.execute("DELETE FROM transport_stream_in_use_pids");
        jdbcTemplate.execute("DELETE FROM transport_stream_in_use_program_numbers");
        jdbcTemplate.execute("DELETE FROM transport_stream_ancillary_stream");
        jdbcTemplate.execute("DELETE FROM transport_stream_property");
        jdbcTemplate.execute("DELETE FROM transport_stream_destination");
        jdbcTemplate.execute("DELETE FROM transport_stream_reserved_pid_range");
        jdbcTemplate.execute("DELETE FROM transport_stream_reserved_program_number_range");
        jdbcTemplate.execute("DELETE FROM program_property");
        jdbcTemplate.execute("DELETE FROM program");
        jdbcTemplate.execute("DELETE FROM transport_stream");
        jdbcTemplate.execute("DELETE FROM stream");

        outputHandler.close();
    }

    protected Integer getNextUniqueStreamPid()
    {
        if (++nextValidPid > PID_MAXIMUM)
        {
            throw new RuntimeException("PIDs used for integration tests exceeded max: " + PID_MAXIMUM);
        }

        return nextValidPid;
    }

    /**
     * Sends a message to the DSS interface and waits for response.
     *
     * @param request request to send
     * @param type type of request
     * @return DSS response
     */
    protected String sendAndWait(final String request, final String type)
    {
        return dssClient.sendAndWait(request, type);
    }

    protected JdbcTemplate getJdbcTemplate()
    {
        return jdbcTemplate;
    }

    /**
     * Verifies that the DSS response is non-error.
     *
     * @param response non erroneous response
     */
    protected void verifyOkResponse(final String response)
    {
        assertThat(String.format("Expected an Ok response and instead got: %s", response), isType(response, OkResponse.class),
            is(true));
    }

    protected boolean isType(final String message, final Class<?> type)
    {
        return StringUtils.containsIgnoreCase(message, String.format("<%s", type.getSimpleName()));
    }

    /**
     * Verifies that the DSS response is non-error.
     *
     * @param response non erroneous response
     */
    protected void verifyNotErrorResponse(final String response)
    {
        assertThat(String.format("Expected a response that was not an error: %s", response), isType(response, ErrorResponse.class),
            is(false));
    }

    /**
     * Verifies that the DSS response is a particular error.
     *
     * @param response actual response
     * @param expectedError expected error response
     * @throws JAXBException on issue processing the error message
     */
    protected void verifyErrorResponseIgnoringDetails(final String response, final ErrorResponse expectedError)
        throws JAXBException
    {
        assertThat(response, notNullValue());
        final ErrorResponse actualResponse = asMessageObject(response, ErrorResponse.class);
        assertThat(actualResponse.getSummary(), is(expectedError.getSummary()));
    }

    protected void verifyIsErrorResponse(final String response) throws JAXBException
    {
        assertThat(response, notNullValue());
        assertThat(isType(response, ErrorResponse.class), is(true));
        final ErrorResponse actualResponse = asMessageObject(response, ErrorResponse.class);
        assertThat(actualResponse, notNullValue());
    }

    protected String randomAddAncillaryStreamToTransportStream() throws JAXBException
    {
        return createAddAncillaryRequestToXml(TRANSPORT_STREAM_ID, getNextUniqueStreamPid(), MAX_AVERAGE, MAX_BURST, MAX_LATENCY, streamProperties);
    }

    protected void addMpegStream(final Long id, final Integer pid, final String destinationAddress, final int destinationPort, final int maxAverageRate, final int maxBurstSize, final int maxShapingLatency)
    {
        final int streamId = getJdbcTemplate().update("INSERT INTO stream (id,pid,dtype,max_average_rate,max_burst_size,max_shaping_latency,transmission_type) values (?,?,?,?,?,?,?)",
            new Object[] {id, pid, "StandaloneStream", maxAverageRate, maxBurstSize, maxShapingLatency, TransmissionType.MPEG2});
        getJdbcTemplate().update("INSERT INTO stream_destination (inet_address,port,stream_destination_id) values (?,?,?)",
            new Object[] {destinationAddress, destinationPort, streamId });
    }

    protected void addDsgBtStream(final Long id, final String destinationAddress, final int destinationPort, final int maxAverageRate, final int maxBurstSize, final int maxShapingLatency)
    {
        final int streamId = getJdbcTemplate().update("INSERT INTO stream (id,dtype,max_average_rate,max_burst_size,max_shaping_latency,transmission_type) values (?,?,?,?,?,?,?)",
            new Object[] {id, "StandaloneStream", maxAverageRate, maxBurstSize, maxShapingLatency, TransmissionType.DSG_BROADCAST_TUNNEL});
        getJdbcTemplate().update("INSERT INTO stream_destination (inet_address,port,stream_destination_id) values (?,?,?)",
            new Object[] {destinationAddress, destinationPort, streamId });
    }

    protected void addPeriodic(final Long periodicId, final long streamId, final String data, final long startTime,
        final Long stopTime, final int insertionRate, final MeteringType meteringType)
    {
        getJdbcTemplate().update(
            "INSERT INTO periodic (id,stream_id,data_type,data,start_time,stop_time,insertion_rate,metering_type) values (?,?,?,?,?,?,?)",
            new Object[] {periodicId, streamId, PeriodicDataType.FUNCTION, data, new Date(startTime), new Date(stopTime),
                insertionRate, meteringType});
    }

    protected void verifyNumberOfStreams(final int numberOfStreams)
    {
        final List<?> results = getJdbcTemplate().queryForList("SELECT * FROM stream;");
        assertThat(String.format("The expected number of streams is %s, while the actual is %s", numberOfStreams, results.size()),
            numberOfStreams, is(results.size()));
    }

    protected void verifyNumberOfTransportStreams(final int numberOfTransportStreams)
    {
        final List<?> results = getJdbcTemplate().queryForList("SELECT * FROM transport_stream;");
        assertThat(String.format("The expected number of transport streams is %s, while the actual is %s", numberOfTransportStreams, results.size()),
            numberOfTransportStreams, is(results.size()));
    }

    protected void verifyNumberOfRoutes(final int numberOfRoutes)
    {
        final List<?> results = getJdbcTemplate().queryForList("SELECT * FROM route;");
        assertThat(String.format("The expected number of routes is %s, while the actual is %s", numberOfRoutes, results.size()),
            numberOfRoutes, is(results.size()));
    }

    protected void verifyNumberOfPeriodics(final int numberOfPeriodics)
    {
        final List<?> results = getJdbcTemplate().queryForList("SELECT * FROM periodic;");
        assertThat(String.format("The expected number of periodics is %s, while the actual is %s", numberOfPeriodics, results
            .size()), numberOfPeriodics, is(results.size()));
    }

    protected void verifyStreamExists(final Long id)
    {
        verifyStreamExists(id, true);
    }

    protected void verifyTransportStreamExists(final int id)
    {
        verifyTransportStreamExists(id, true);
    }

    protected void verifyStreamDoesNotExist(final Long id)
    {
        verifyStreamExists(id, false);
    }

    protected void verifyTransportStreamDoesNotExist(final int id)
    {
        verifyTransportStreamExists(id, false);
    }

    protected void verifyRouteDoesNotExist(final Long id)
    {
        verifyRouteExists(id, false);
    }

    /**
     * Verifies if a stream exists with the given id.
     *
     * @param id stream to verify
     * @param verifyExists true it this method should verify that it exists, false if it should verify that it does not exist
     */
    private void verifyStreamExists(final Long id, final boolean verifyExists)
    {
        final List<?> results = getJdbcTemplate()
            .queryForList("SELECT stream.id FROM stream WHERE stream.id=?", new Object[] {id });
        if (verifyExists)
        {
            assertThat(String.format("The stream with id %s should exist, but it does not.", id), results.size(), is(1));
        }
        else
        {
            assertThat(String.format("The stream with id %s should not exist, but it does.", id), results.size(), is(0));
        }
    }

    private void verifyShaperExists(final Long id, final boolean verifyExists)
    {
        final List<?> results = getJdbcTemplate()
            .queryForList("SELECT shaper.id FROM shaper WHERE shaper.id=?", new Object[] {id });
        if (verifyExists)
        {
            assertThat(String.format("The shaper with id %s should exist, but it does not.", id), results.size(), is(1));
        }
        else
        {
            assertThat(String.format("The shaper with id %s should not exist, but it does.", id), results.size(), is(0));
        }
    }

    long getPatStreamIdFromTransportStream(final int id)
    {
        return getJdbcTemplate()
            .queryForInt("SELECT pat_stream_id FROM pat_stream_transport_stream WHERE transport_stream_id=?", new Object[] {id });
    }

    long getPmtStreamIdFromProgramNumber(final int programNumber)
    {
        return getJdbcTemplate()
            .queryForInt("SELECT pmt_stream_id FROM pmt_stream_program WHERE program_number=?", new Object[] {programNumber });
    }

    /**
     * Verifies if a transport stream exists with the given id.
     *
     * @param id transport stream to verify
     * @param verifyExists true it this method should verify that it exists, false if it should verify that it does not exist
     */
    private void verifyTransportStreamExists(final int id, final boolean verifyExists)
    {
        final List<?> results = getJdbcTemplate()
            .queryForList("SELECT transport_stream.id FROM transport_stream WHERE transport_stream.id=?", new Object[] {id });
        if (verifyExists)
        {
            assertThat(String.format("The transport stream with id %s should exist, but it does not.", id), results.size(), is(1));
        }
        else
        {
            assertThat(String.format("The transport stream with id %s should not exist, but it does.", id), results.size(), is(0));
        }
    }

    private void verifyRouteExists(final Long id, final boolean verifyExists)
    {
        final List<?> results = getJdbcTemplate()
            .queryForList("SELECT route.id FROM route WHERE route.id=?", new Object[] {id });
        if (verifyExists)
        {
            assertThat(String.format("The route with id %s should exist, but it does not.", id), results.size(), is(1));
        }
        else
        {
            assertThat(String.format("The route with id %s should not exist, but it does.", id), results.size(), is(0));
        }
    }

    protected void verifyDestinationExists(final String destinationAddress, final int destinationPort)
    {
        verifyDestinationExists(destinationAddress, destinationPort, true);
    }

    protected void verifyDestinationDoesNotExist(final String destinationAddress, final int destinationPort)
    {
        verifyDestinationExists(destinationAddress, destinationPort, false);
    }

    /**
     * Verifies if a destination exists for the given destination address and port.
     *
     * @param destinationAddress hostname or ip address of the destination
     * @param destinationPort port of the destination
     * @param verifyExists true it this method should verify that it exists, false if it should verify that it does not exist
     */
    private void verifyDestinationExists(final String destinationAddress, final int destinationPort, final boolean verifyExists)
    {
        final List<?> results = getJdbcTemplate().queryForList(
            "SELECT * FROM stream_destination WHERE stream_destination.inet_address=? and stream_destination.port=?  ",
            new Object[] {destinationAddress, destinationPort });
        if (verifyExists)
        {
            assertThat(String.format("The destination with ip address %s should exist, but it does not.", destinationAddress),
                results.size(), is(1));
        }
        else
        {
            assertThat(String.format("The destination with ip address %s should exist, but it does not.", destinationAddress),
                results.size(), is(0));
        }
    }

    /**
     * Verifies if a destination exists for the given transport stream.
     *
     * @param destinationAddress hostname or ip address of the destination
     * @param destinationPort port of the destination
     */
    protected void verifyDestinationExistsForTransportStream(final String destinationAddress, final int destinationPort, final int transportStreamId)
    {
        final List<?> results = getJdbcTemplate()
            .queryForList(
                "SELECT * FROM transport_stream_destination WHERE transport_stream_destination.inet_address=? and transport_stream_destination.port=?  and transport_stream_destination_id=?",
                new Object[] {destinationAddress, destinationPort, transportStreamId });
        assertThat(String.format("The destination with ip address %s should exist, but it does not.", destinationAddress), results
            .size(), is(1));
    }

    /**
     * Verifies if a destination exists for the given stream.
     *
     * @param destinationAddress hostname or ip address of the destination
     * @param destinationPort port of the destination
     * @param streamId id of the stream destination to verify
     */
    protected void verifyDestinationExistsForStream(final String destinationAddress, final int destinationPort, final Long streamId)
    {
        final List<?> results = getJdbcTemplate()
            .queryForList(
                "SELECT * FROM stream_destination WHERE stream_destination.inet_address=? and stream_destination.port=?  and stream_destination_id=?",
                new Object[] {destinationAddress, destinationPort, streamId });
        assertThat(String.format("The destination with ip address %s should exist, but it does not.", destinationAddress), results
            .size(), is(1));
    }

    /**
     * Verifies if number of transport stream destinations exists.
     *
     * @param id transport stream destination id to verify
     * @param numberOfDestination number of distinations expected
     */
    protected void verifyNumberOfTransportStreamDestinations(final int id, final int numberOfDestination)
    {
        final List<?> results = getJdbcTemplate()
            .queryForList(
                "SELECT transport_stream_destination.transport_stream_destination_id FROM transport_stream_destination WHERE transport_stream_destination.transport_stream_destination_id=?",
                new Object[] {id });

        assertThat(numberOfDestination, is(results.size()));
    }

    /**
     * Verifies if number of stream destination's exists.
     *
     * @param id stream destination id to verify
     * @param numberOfDestination number of distinations expected
     */
    protected void verifyNumberOfStreamDestinations(final Long id, final int numberOfDestination)
    {
        final List<?> results = getJdbcTemplate()
            .queryForList(
                "SELECT stream_destination.stream_destination_id FROM stream_destination WHERE stream_destination.stream_destination_id=?",
                new Object[] {id });

        assertThat(numberOfDestination, is(results.size()));
    }

    /**
     * Verifies if a stream exists with the given shaping parameters.
     *
     * @param id stream to verify
     * @param maxAverageRate maximum average bytes per second
     * @param maxBurstSize maximum burst size in bytes
     * @param maxShapingLatency maximum shaping latency seconds of delayed packets
     */
    private void verifyExpectedStreamShapingParameters(final Long id, final int maxAverageRate,
        final int maxBurstSize, final int maxShapingLatency)
    {
        final List<?> results = getJdbcTemplate()
            .queryForList("SELECT stream.id FROM stream WHERE stream.id=? and stream.max_average_rate=? and stream.max_burst_size=? and stream.max_shaping_latency=?",
                new Object[] {id, maxAverageRate, maxBurstSize, maxShapingLatency});
        assertThat(String.format("The stream with id %s should have maxAverageRate = %s, maxBurstSize = %s, maxShapingLatency = %s, but different values were found.",
            id, maxAverageRate, maxBurstSize, maxShapingLatency), results.size(), is(1));
    }

    /**
     * Verifies if a transport stream exists with the given shaping parameters.
     *
     * @param id stream to verify
     * @param maxAverageRate maximum average bytes per second
     * @param maxBurstSize maximum burst size in bytes
     * @param maxShapingLatency maximum shaping latency seconds of delayed packets
     */
    protected void verifyExpectedTransportStreamShapingParameters(final int id, final int maxAverageRate,
        final int maxBurstSize, final int maxShapingLatency)
    {
        final List<?> results = getJdbcTemplate()
            .queryForList("SELECT transport_stream.id FROM transport_stream WHERE transport_stream.id=? and transport_stream.max_average_rate=? and transport_stream.max_burst_size=? and transport_stream.max_shaping_latency=?",
                new Object[] {id, maxAverageRate, maxBurstSize, maxShapingLatency});
        assertThat(String.format("The transport stream with id %s should have maxAverageRate = %s, maxBurstSize = %s, maxShapingLatency = %s, but different values were found.",
            id, maxAverageRate, maxBurstSize, maxShapingLatency), results.size(), is(1));
    }

    protected void verifyPeriodicPersisted(final Long id)
    {
        try
        {
            MoreHamcrest.waitUntil(Boolean.TRUE, periodicPersisted(id), 2000L);
        }
        catch (final TimeoutException te)
        {
            fail(String.format("The periodic with id %s should exist.", id));
        }
    }

    protected void verifyPeriodicNotPersisted(final Long id)
    {
        try
        {
            MoreHamcrest.waitUntil(Boolean.FALSE, periodicPersisted(id), 2000L);
        }
        catch (final TimeoutException te)
        {
            fail(String.format("The periodic with id %s should not exist.", id));
        }
    }

    protected void verifyShaperPersisted(final Long id)
    {
        try
        {
            MoreHamcrest.waitUntil(Boolean.TRUE, shaperPersisted(id), 2000L);
        }
        catch (final TimeoutException te)
        {
            fail(String.format("The shaper with id %s should exist.", id));
        }
    }

    protected void verifyShaperNotPersisted(final Long id)
    {
        try
        {
            MoreHamcrest.waitUntil(Boolean.FALSE, shaperPersisted(id), 2000L);
        }
        catch (final TimeoutException te)
        {
            fail(String.format("The shaper with id %s should not exist.", id));
        }
    }

    protected void verifyProgramPersisted(final int programNumber, final int transportStreamId)
    {
        try
        {
            MoreHamcrest.waitUntil(Boolean.TRUE, programPersisted(programNumber, transportStreamId), 2000L);
        }
        catch (final TimeoutException te)
        {
            fail(String.format("The program with number %s should exist.", programNumber));
        }
    }

    protected void verifyProgramNotPersisted(final int programNumber, final int transportStreamId)
    {
        try
        {
            MoreHamcrest.waitUntil(Boolean.FALSE, programPersisted(programNumber, transportStreamId), 2000L);
        }
        catch (final TimeoutException te)
        {
            fail(String.format("The program with number %s should not exist.", programNumber));
        }
    }

    private org.hamcrest.Matcher<Boolean> periodicPersisted(final Long id)
    {
        return new BaseMatcher<Boolean>() {
            @Override
            public boolean matches(final Object toMatch)
            {
                if (!(toMatch instanceof Boolean))
                {
                    return false;
                }

                final Boolean isPersisted = (Boolean)toMatch;
                final List<?> results = getJdbcTemplate().queryForList("SELECT periodic.id FROM periodic WHERE periodic.id=?",
                    new Object[] {id });
                return isPersisted == (results.size() == 1);
            }

            @Override
            public void describeTo(final Description description)
            {
                description.appendText(String.format("The periodic with id %s should not exist.", id));
            }
        };
    }

    private org.hamcrest.Matcher<Boolean> shaperPersisted(final Long id)
    {
        return new BaseMatcher<Boolean>() {
            @Override
            public boolean matches(final Object toMatch)
            {
                if (!(toMatch instanceof Boolean))
                {
                    return false;
                }

                final Boolean isPersisted = (Boolean)toMatch;
                final List<?> results = getJdbcTemplate().queryForList("SELECT shaper.id FROM shaper WHERE shaper.id=?",
                    new Object[] {id });
                return isPersisted == (results.size() == 1);
            }

            @Override
            public void describeTo(final Description description)
            {
                description.appendText(String.format("The shaper with id %s should not exist.", id));
            }
        };
    }

    private org.hamcrest.Matcher<Boolean> programPersisted(final int programNumber, final int transportStreamId )
    {
        return new BaseMatcher<Boolean>() {
            @Override
            public boolean matches(final Object toMatch)
            {
                if (!(toMatch instanceof Boolean))
                {
                    return false;
                }

                final Boolean isPersisted = (Boolean)toMatch;
                final List<?> results = getJdbcTemplate().queryForList("SELECT program_number FROM program WHERE program_number=? AND transport_stream_id=?",
                    new Object[] {programNumber, transportStreamId});
                return isPersisted == (results.size() == 1);
            }

            @Override
            public void describeTo(final Description description)
            {
                description.appendText(String.format("The program with number %s should not exist.", programNumber));
            }
        };
    }

    protected Long getStreamIdForPeriodic(final Long id)
    {
        return getJdbcTemplate().queryForLong("SELECT periodic.stream_id FROM periodic WHERE periodic.id=?",
            new Object[] {id });
    }

    protected void verifyPeriodicExistsByStreamId(final Long id)
    {
        assertThat(String.format("The periodic with id %s should exist, but it does not.", id), periodicExistsByStreamId(id),
            is(true));
    }

    protected void verifyPeriodicDoesNotExistByStreamId(final Long id)
    {
        assertThat(String.format("The periodic with id %s should not exist, but it does.", id), periodicExistsByStreamId(id),
            not(true));
    }

    protected boolean periodicExistsByStreamId(final Long id)
    {
        final List<?> results = getJdbcTemplate().queryForList("SELECT periodic.id FROM periodic WHERE periodic.stream_id=?",
            new Object[] {id });
        return results.size() == 1;
    }

    /**
     * Get the stream id from the create response message.
     *
     * @param message response message
     * @return stream id
     * @throws Exception if an exception occurs.
     */
    protected Long getStreamIdFromCreateResponse(final String message) throws Exception
    {
        final CreateStandaloneStreamResponse response = asMessageObject(message, CreateStandaloneStreamResponse.class);
        return response.getId();
    }

    protected String getStreamTypeFromStreamId(final Long streamId)
    {
        return getJdbcTemplate().queryForObject("SELECT stream.dtype FROM stream WHERE stream.id=?", String.class, streamId);
    }

    protected Integer getPidFromStreamId(final Long streamId)
    {
        return getJdbcTemplate().queryForInt("SELECT stream.pid FROM stream WHERE stream.id=?", streamId);
    }

    protected Integer getProgramNumberForComponentStreamId(final Long streamId)
    {
        return getJdbcTemplate().queryForInt("SELECT pcs.program_number FROM program_component_stream pcs WHERE pcs.component_stream_id=?", streamId);
    }

    protected Long getTransportStreamIdForProgramNumber(final Integer programNumber)
    {
        return getJdbcTemplate().queryForLong("SELECT program.transport_stream_id FROM program WHERE program.program_number=?", programNumber);
    }

    protected Long getTransportStreamIdForAncillaryStreamId(final Long streamId)
    {
        return getJdbcTemplate().queryForLong("SELECT tsas.transport_stream_id FROM transport_stream_ancillary_stream tsas WHERE tsas.ancillary_stream_id=?", streamId);
    }

    /**
     * Creates a blocks array with one block with specified length.
     *
     * @param length length of the block
     * @return pupulated blocks array
     */
    private byte[][] createSingleBlock(final int length)
    {
        final byte[][] blocks = new byte[1][length];
        Arrays.fill(blocks[0], TEST_BLOCK_DATA_VALUE);
        return blocks;
    }

    protected void verifyDatagramPacketForCorrectMpegContent(final Integer pid, final int mpegPacketCountInDatagram,
        final int mpegPacketDataLength, final DatagramPacket packet) throws Exception
    {
        final int[] mpegPacketCountInDatagrams = new int[] {mpegPacketCountInDatagram };
        final int[] mpegPacketDataLengths = new int[] {mpegPacketDataLength };
        verifyDatagramPacketsForCorrectMpegContent(pid, mpegPacketCountInDatagrams, mpegPacketDataLengths, packet);
    }

    protected void verifyDatagramPacketForCorrectMpegContent(final Integer pid, final int mpegPacketCountInDatagram,
        final int[] mpegPacketDataLengths, final DatagramPacket packet) throws Exception
    {
        final int[] mpegPacketCountInDatagrams = new int[] {mpegPacketCountInDatagram };
        verifyDatagramPacketsForCorrectMpegContent(pid, mpegPacketCountInDatagrams, mpegPacketDataLengths, packet);
    }

    /**
     * UDP does not guarantee packet arrivals in the order that they were sent. However, since it is an integration test and always
     * uses the loop back IP address, we assume that the UDP packets are going to arrive in the order that they were sent.
     *
     * @param pid packet identifier for MPEG stream
     * @param mpegPacketsDatagram
     * @param mpegPacketDataLengths
     * @param packets
     */
    protected void verifyDatagramPacketsForCorrectMpegContent(final Integer pid, final int[] mpegPacketsDatagram,
        final int[] mpegPacketDataLengths, final DatagramPacket... packets) throws Exception
    {
        ByteArrayInputStream is = null;
        BitInputStream bs = null;
        int contCounter = 0;
        int mpegPacketCounter = 0;
        try
        {
            int i = 0;
            for (final DatagramPacket packet : packets)
            {
                assertThat(packet.getLength(), is(mpegPacketsDatagram[i] * MPEG_PACKET_SIZE));
                final byte[] data = packet.getData();
                int dataBufferIndex = 0;

                for (int j = 0; j < mpegPacketsDatagram[i]; j++)
                {
                    is = new ByteArrayInputStream(data, dataBufferIndex, dataBufferIndex + MPEG_PACKET_SIZE);
                    bs = new BitInputStream(is);
                    boolean startPayload = false;
                    if (j == 0 && i == 0)
                    {
                        startPayload = true;
                    }
                    verifyMpegPacketHeader(bs, pid, startPayload, contCounter);
                    verifyMpegPacketPayload(bs, mpegPacketDataLengths[mpegPacketCounter], startPayload);

                    dataBufferIndex = dataBufferIndex + MPEG_PACKET_SIZE;
                    contCounter++;
                    contCounter = contCounter == 16 ? 0 : contCounter;
                    mpegPacketCounter++;
                }
                i++;
            }
        }
        finally
        {
            try
            {
                is.close();
                bs.close();
            }
            catch (final IOException e)
            {
                // Ignore; without this catch, if an exception was thrown while a stream was positioned mid-byte, the close will fail
            }
        }
    }

    private void verifyMpegPacketHeader(final BitInputStream bs, final Integer pid, final boolean payloadStart,
        final int continuityCounter) throws Exception
    {
        final int syncByte = bs.read();
        assertThat(syncByte, is(0x47));

        final int transportErrorIndicatorBit = bs.readBits(1);
        assertThat(transportErrorIndicatorBit, is(0));

        final int payloadUnitStartIndicatorBit = bs.readBits(1);
        assertPayloadStartIndicator(payloadStart, payloadUnitStartIndicatorBit);

        final int transportPriorityBit = bs.readBits(1);
        assertThat(transportPriorityBit, is(0));

        final int pidBits = bs.readBits(13);
        assertThat(pidBits, is(pid));

        final int trasportScramblingControlBits = bs.readBits(2);
        assertThat(trasportScramblingControlBits, is(0));

        final int adaptationFieldControlBits = bs.readBits(2);
        assertThat(adaptationFieldControlBits, is(1));

        final int continuityCounterBits = bs.readBits(4);
        assertThat(continuityCounterBits, is(continuityCounter));
    }

    private void assertPayloadStartIndicator(final boolean payloadStart, final int payloadUnitStartIndicatorBit)
    {
        if (payloadStart)
        {
            assertThat(payloadUnitStartIndicatorBit, is(1));
        }
        else
        {
            assertThat(payloadUnitStartIndicatorBit, is(0));
        }
    }

    private void verifyMpegPacketPayload(final BitInputStream bs, final int blockSize, final boolean firstPacket) throws Exception
    {
        int payloadLength = MPEG_PACKET_PAYLOAD_SIZE;
        if (firstPacket)
        {
            final int firstByteOfPayloadInFirstPacket = bs.read();
            assertThat(firstByteOfPayloadInFirstPacket, is(0));
            payloadLength = MPEG_PACKET_PAYLOAD_SIZE_FOR_FIRST_IN_SERIES;
        }
        for (int i = 0; i < blockSize; i++)
        {
            final int payloadByte = bs.read();
            assertThat(payloadByte, is((int)TEST_BLOCK_DATA_VALUE));
        }
        for (int i = 0; i < payloadLength - blockSize; i++)
        {
            final int payloadByte = bs.read();
            assertThat(payloadByte, is(MPEG_PADDING_BYTE));
        }
    }

    protected long setupDataForPeriodicFiringToTrigger(final Integer pid, final TransmissionType transmissionType, final int maxAverageRate, final int maxBurstSize, final int maxShapingLatency, final int insertionRate, final int blockSize,
        final StreamDestinationInfo... desintationInfos) throws Exception
    {
        final long streamId = createStream(streamProperties, pid, transmissionType, maxAverageRate, maxBurstSize, maxShapingLatency, desintationInfos);
        return addUnendingPeriodic(streamId, blockSize, insertionRate);
    }

    protected String updateMpeg2TransportStreamRequestToXml(final int streamId, final StreamDestinationInfo... desintationInfos) throws UnknownHostException, JAXBException
    {
        final List<StreamDestinationInfo> destinations = prepareDestinationInfo(desintationInfos);
        return asXml(new UpdateMpeg2TransportStreamDestinationsRequest(streamId, destinations));
    }

    protected String updateStreamRequestToXml(final long streamId, final StreamDestinationInfo... desintationInfos) throws UnknownHostException, JAXBException
    {
        final List<StreamDestinationInfo> destinations = prepareDestinationInfo(desintationInfos);
        return asXml(new UpdateStandaloneStreamDestinationsRequest(streamId, destinations));
    }

    private List<StreamDestinationInfo> prepareDestinationInfo(final StreamDestinationInfo... desintationInfos)
    {
        final List<StreamDestinationInfo> destinations = new ArrayList<StreamDestinationInfo>();

        if (desintationInfos != null)
        {
            destinations.addAll(Arrays.asList(desintationInfos));
        }

        return destinations;
    }

    private List<DestinationInfo> prepareDestinationInfo(final DestinationInfo... destinationInfos)
    {
        final List<DestinationInfo> destinations = new ArrayList<DestinationInfo>();
        destinations.addAll(Arrays.asList(destinationInfos));
        return destinations;
    }

    protected String updateStandaloneStreamDestinationsRequestToXml(final long streamId, final StreamDestinationInfo... desintationInfos)
        throws UnknownHostException, JAXBException
    {
        final List<StreamDestinationInfo> destinations = prepareDestinationInfo(desintationInfos);
        return asXml(new UpdateStandaloneStreamDestinationsRequest(streamId, destinations));
    }

    private String updateStreamShapingPolicyRequestToXml(final long streamId, final int maxAverageRate, final int maxBurstSize, final int maxShapingLatency)
        throws UnknownHostException, JAXBException
    {
        return asXml(new UpdateStreamShapingPolicyRequest(streamId, new TrafficShapingProfile(maxAverageRate, maxBurstSize, maxShapingLatency)));
    }

    private String updateShaperRequestToXml(final long shaperId, final int maxAverageRate, final int maxBurstSize, final int maxShapingLatency)
        throws UnknownHostException, JAXBException
    {
        return asXml(new UpdateShaperRequest(shaperId, new TrafficShapingProfile(maxAverageRate, maxBurstSize, maxShapingLatency)));
    }

    protected String updateTransportStreamShapingPolicyRequestToXml(final int transportStreamId, final int maxAverageRate, final int maxBurstSize, final int maxShapingLatency)
        throws UnknownHostException, JAXBException
    {
        return asXml(new UpdateTransportStreamShapingPolicyRequest(transportStreamId, new TrafficShapingProfile(maxAverageRate, maxBurstSize, maxShapingLatency)));
    }

    protected String updateTransportStreamPropertiesRequestToXml(final int transportStreamId, final Map<String, String> properties)
        throws UnknownHostException, JAXBException
    {
        return asXml(new UpdateTransportStreamPropertiesRequest(transportStreamId, properties));
    }

    protected String createUpdateProgramRequestToXml(final int transportStreamId, final int programNumber, final Map<String, String> properties) throws JAXBException
    {
        final UpdateProgramRequest updateProgramRequest = new UpdateProgramRequest(transportStreamId, programNumber, properties);
        return asXml(updateProgramRequest);
    }

    protected String createDeleteProgramRequestToXml(final int transportStreamId, final int programNumber) throws JAXBException
    {
        final DeleteProgramRequest deleteProgramRequest = new DeleteProgramRequest(transportStreamId, programNumber);
        return asXml(deleteProgramRequest);
    }

    protected String createAddAncillaryRequestToXml(final int transportStreamId, final int pid, final int maxAverageRate, final int maxBurstSize, final int maxShapingLatency, final Map<String, String> properties) throws JAXBException
    {
        final AddAncillaryStreamRequest addAncillaryStreamRequest = new AddAncillaryStreamRequest(transportStreamId, pid, new TrafficShapingProfile(maxAverageRate, maxBurstSize, maxShapingLatency), properties);
        return asXml(addAncillaryStreamRequest);
    }

    protected String createAddAncillaryWithShaperRequestToXml(final int transportStreamId, final int pid, final long shaperId, final Map<String, String> properties) throws JAXBException
    {
        final AddAncillaryStreamRequest addAncillaryStreamRequest = new AddAncillaryStreamRequest(transportStreamId, pid, shaperId, properties);
        return asXml(addAncillaryStreamRequest);
    }

    protected String createAddComponentRequestToXml(final int transportStreamId, final int programNumber, final int componentStreamType, final int maxAverageRate, final int maxBurstSize, final int maxShapingLatency, final Map<String, String> properties) throws JAXBException
    {
        final AddComponentStreamRequest addComponentStreamRequest = new AddComponentStreamRequest(transportStreamId, programNumber, componentStreamType, new TrafficShapingProfile(maxAverageRate, maxBurstSize, maxShapingLatency), properties);
        return asXml(addComponentStreamRequest);
    }

    protected String createStreamRequestToXml(final Map<String, String> properties, final Integer pid, final TransmissionType transmissionType, final int maxAverageRate, final int maxBurstSize, final int maxShapingLatency, final StreamDestinationInfo... destinationInfos)
        throws UnknownHostException, JAXBException
    {
        final List<StreamDestinationInfo> destinations = prepareDestinationInfo(destinationInfos);
        final CreateStandaloneStreamRequest createStandaloneStreamRequest = new CreateStandaloneStreamRequest(properties, pid, destinations, transmissionType, new TrafficShapingProfile(maxAverageRate, maxBurstSize, maxShapingLatency));
        return asXml(createStandaloneStreamRequest);
    }

    protected String createShaperRequestToXml(final int transportStreamId, final Map<String, String> properties, final int maxAverageRate, final int maxBurstSize, final int maxShapingLatency)
        throws UnknownHostException, JAXBException
    {
        final CreateShaperRequest createShaperRequest = new CreateShaperRequest(transportStreamId, properties, new TrafficShapingProfile(maxAverageRate, maxBurstSize, maxShapingLatency));
        return asXml(createShaperRequest);
    }

    protected String createMpeg2TransportStreamRequestToXml(final Map<String, String> properties, final Integer networkPid,
        final List<IntegerRangeSummary> reservedPidRanges, final List<IntegerRangeSummary> reservedProgramNumberRanges, final StreamDestinationInfo... destinationInfos)
        throws UnknownHostException, JAXBException
    {
        final List<StreamDestinationInfo> destinations = prepareDestinationInfo(destinationInfos);
        final CreateMpeg2TransportStreamRequest createMpeg2TransportStreamRequest = new CreateMpeg2TransportStreamRequest(destinations, networkPid, reservedPidRanges, reservedProgramNumberRanges, properties, new TrafficShapingProfile(MAX_AVERAGE, MAX_BUFFER_VALUE, MAX_BUFFER_VALUE));
        return asXml(createMpeg2TransportStreamRequest);
    }

    protected String updateMpeg2TransportStreamDestinationsRequestToXml(final int id, final StreamDestinationInfo... destinationInfos)
        throws UnknownHostException, JAXBException
    {
        final List<StreamDestinationInfo> destinations = prepareDestinationInfo(destinationInfos);
        final UpdateMpeg2TransportStreamDestinationsRequest updateMpeg2TransportStreamDestinationsRequest = new UpdateMpeg2TransportStreamDestinationsRequest(id, destinations);
        return asXml(updateMpeg2TransportStreamDestinationsRequest);
    }

    protected String createIpDirectTransportStreamRequestToXml(final Map<String, String> properties, final int basePort, final Integer networkPid,
        final List<IntegerRangeSummary> reservedPidRanges, final List<IntegerRangeSummary> reservedProgramNumberRanges, final DestinationInfo... destinationInfos)
        throws UnknownHostException, JAXBException
    {
        final List<DestinationInfo> destinations = prepareDestinationInfo(destinationInfos);
        final CreateIpDirectTransportStreamRequest createIpDirectTransportStreamRequest = new CreateIpDirectTransportStreamRequest(destinations, basePort, networkPid, reservedPidRanges, reservedProgramNumberRanges, properties, new TrafficShapingProfile(MAX_AVERAGE, MAX_BUFFER_VALUE, MAX_BUFFER_VALUE));
        return asXml(createIpDirectTransportStreamRequest);
    }

    protected String updateIpDirectTransportStreamDestinationsRequestToXml(final int id, final DestinationInfo... destinationInfos)
        throws UnknownHostException, JAXBException
    {
        final List<DestinationInfo> destinations = prepareDestinationInfo(destinationInfos);
        final UpdateIpDirectTransportStreamDestinationsRequest updateIpDirectTransportStreamDestinationsRequest = new UpdateIpDirectTransportStreamDestinationsRequest(id, destinations);
        return asXml(updateIpDirectTransportStreamDestinationsRequest);
    }

    protected String randomUpdateProgramRequestToXml() throws JAXBException
    {
        return createUpdateProgramRequestToXml(TRANSPORT_STREAM_ID, 1, programProperties);
    }

    protected String randomDeleteProgramRequestToXml() throws JAXBException
    {
        return createDeleteProgramRequestToXml(TRANSPORT_STREAM_ID, 1);
    }

    protected String randomAddAncillaryStreamToTransportStreamToXml() throws JAXBException
    {
        return createAddAncillaryRequestToXml(TRANSPORT_STREAM_ID, getNextUniqueStreamPid(), MAX_AVERAGE, MAX_BURST, MAX_LATENCY, streamProperties);
    }

    protected String randomAddAncillaryStreamToTransportStreamWithShaperToXml(final long shaperId) throws JAXBException
    {
        return createAddAncillaryWithShaperRequestToXml(TRANSPORT_STREAM_ID, getNextUniqueStreamPid(), shaperId, streamProperties);
    }

    protected String randomAddComponentStreamToTransportStreamToXml() throws JAXBException
    {
        return createAddComponentRequestToXml(TRANSPORT_STREAM_ID, 1, 1, MAX_AVERAGE, MAX_BURST, MAX_LATENCY, streamProperties);
    }

    protected String randomUpdateStandAloneStreamDestinationsRequestToXml() throws UnknownHostException, JAXBException
    {
        return updateStandaloneStreamDestinationsRequestToXml(2L, new StreamDestinationInfo(IP_STRING, PORT1));
    }

    protected String randomUpdateTransportStreamShapingPolicyRequestToXml() throws UnknownHostException, JAXBException
    {
        return updateTransportStreamShapingPolicyRequestToXml(2, MAX_AVERAGE, MAX_BURST, MAX_LATENCY);
    }

    protected String randomUpdateTransportStreamPropertiesRequestToXml() throws UnknownHostException, JAXBException
    {
        return updateTransportStreamPropertiesRequestToXml(2, transportStreamProperties);
    }

    protected String randomUpdateShaperRequestToXml(final long shaperId) throws UnknownHostException, JAXBException
    {
        return updateStreamShapingPolicyRequestToXml(shaperId, MAX_AVERAGE, MAX_BURST, MAX_LATENCY);
    }

    protected String randomUpdateStreamShapingPolicyRequestToXml() throws UnknownHostException, JAXBException
    {
        return updateStreamShapingPolicyRequestToXml(2L, MAX_AVERAGE, MAX_BURST, MAX_LATENCY);
    }

    protected String randomCreateMpeg2StreamRequestToXml() throws UnknownHostException, JAXBException
    {
        return createStreamRequestToXml(streamProperties, getNextUniqueStreamPid(), TransmissionType.MPEG2, MAX_AVERAGE, MAX_BURST, MAX_LATENCY, new StreamDestinationInfo(IP_STRING, PORT1));
    }

    protected String randomCreateShaperRequestToXml(final int transportStreamId) throws UnknownHostException, JAXBException
    {
        return createShaperRequestToXml(transportStreamId, shaperProperties, MAX_AVERAGE, MAX_BURST, MAX_LATENCY);
    }

    protected String randomUpdateMpeg2TransportStreamDestinationsRequestToXml(final int id) throws UnknownHostException, JAXBException
    {
        return updateMpeg2TransportStreamDestinationsRequestToXml(id, new StreamDestinationInfo(IP_STRING3, PORT3));
    }

    protected String randomCreateIpDirectTransportStreamRequestToXml() throws UnknownHostException, JAXBException
    {
        return createIpDirectTransportStreamRequestToXml(streamProperties, 5001, 6888, reservedPidRanges, reservedProgramNumberRange, new DestinationInfo(IP_STRING));
    }

    protected String randomCreateMpeg2TransportStreamRequestToXml() throws UnknownHostException, JAXBException
    {
        return createMpeg2TransportStreamRequestToXml(streamProperties, 5001,  reservedPidRanges, reservedProgramNumberRange,  new StreamDestinationInfo(IP_STRING3, PORT3));
    }

    protected String randomUpdateIpDirectTransportStreamDestinationsRequestToXml(final int id) throws UnknownHostException, JAXBException
    {
        return updateIpDirectTransportStreamDestinationsRequestToXml(id, new DestinationInfo(IP_STRING3));
    }

    protected long createStream(final Integer pid, final TransmissionType transmissionType, final int maxAverageRate, final int maxBurstSize, final int maxShapingLatency) throws Exception
    {
        return createStream(streamProperties, pid, transmissionType, maxAverageRate, maxBurstSize, maxShapingLatency, new StreamDestinationInfo(IP_STRING, PORT1));
    }

    protected long createStreamOnAddressAndPort(final Integer pid, final TransmissionType transmissionType, final int maxAverageRate,
        final int maxBurstSize, final int maxShapingLatency, final String ipAddress, final int port) throws Exception
    {
        return createStream(streamProperties, pid, transmissionType, maxAverageRate, maxBurstSize, maxShapingLatency, new StreamDestinationInfo(ipAddress, port));
    }

    protected long createAnMpegElementaryStream(final Integer pid, final String ipAddress, final int port) throws Exception
    {
        return (createStreamOnAddressAndPort(pid, TransmissionType.MPEG2, MAX_AVERAGE, MAX_BUFFER_VALUE, MAX_LATENCY,
            ipAddress, port));
    }

    protected long createAnIpDirectElementaryStream(final Integer pid, final String ipAddress, final int port) throws Exception
    {
        return (createStreamOnAddressAndPort(pid, TransmissionType.IP_DIRECT, MAX_AVERAGE, MAX_BUFFER_VALUE, MAX_LATENCY,
            ipAddress, port));
    }

    /**
     * Creates a stream through the DSS via messaging.
     *
     * @param properties properties of the stream
     * @param pid packet identifier for MPEG stream, null for other stream types
     * @param destinationInfos destinations to add to the streams
     * @param transmissionType type of the stream
     * @return stream id
     * @throws UnknownHostException
     */
    protected long createStream(final Map<String, String> properties, final Integer pid, final TransmissionType transmissionType, final int maxAverageRate, final int maxBurstSize, final int maxShapingLatency, final StreamDestinationInfo... destinationInfos) throws Exception
    {
        return dssClient.createStream(properties, pid, destinationInfos, transmissionType, maxAverageRate, maxBurstSize, maxShapingLatency);
    }

    /**
     * Creates a MPEG2 transport stream through the DSS via messaging.
     *
     * @param destinationInfos destinations to add to the streams
     * @param networkPid network pid of the transport stream if not null
     * @param reservedPidRanges pid value ranges which should not be used
     * @param properties properties of the stream
     * @param maxAverageRate
     * @param maxBurstSize
     * @param maxShapingLatency
     * @return reservedProgramNumberRanges program number value ranges which should not be used
     * @throws UnknownHostException
     */
    protected int createMpeg2TransportStream(final List<StreamDestinationInfo> destinationInfos, final Integer networkPid, final List<IntegerRangeSummary> reservedPidRanges, final List<IntegerRangeSummary> reservedProgramNumberRanges, final Map<String, String> properties,
        final int maxAverageRate, final int maxBurstSize, final int maxShapingLatency) throws Exception
    {
        return dssClient.createMpeg2TransportStream(destinationInfos, networkPid, reservedPidRanges, reservedProgramNumberRanges, properties, maxAverageRate, maxBurstSize, maxShapingLatency);
    }

    /**
     * Creates a Ip Direct transport stream through the DSS via messaging.
     *
     * @param destinationInfos destinations to add to the streams
     * @param basePort of the transport stream
     * @param networkPid network pid of the transport stream if not null
     * @param reservedPidRanges pid value ranges which should not be used
     * @param properties properties of the stream
     * @param maxAverageRate
     * @param maxBurstSize
     * @param maxShapingLatency
     * @return reservedProgramNumberRanges program number value ranges which should not be used
     * @throws UnknownHostException
     */
    protected int createIpDirectTransportStream(final List<DestinationInfo> destinationInfos, final int basePort, final Integer networkPid, final List<IntegerRangeSummary> reservedPidRanges, final List<IntegerRangeSummary> reservedProgramNumberRanges, final Map<String, String> properties,
        final int maxAverageRate, final int maxBurstSize, final int maxShapingLatency) throws Exception
    {
        return dssClient.createIpDirectTransportStream(destinationInfos, basePort, networkPid, reservedPidRanges, reservedProgramNumberRanges, properties, maxAverageRate, maxBurstSize, maxShapingLatency);
    }

    /**
     * Adds a periodic through the DSS via messaging.
     *
     * @param streamId stream id
     * @param blockSize length of the data block to generate
     * @param insertionRate the periodic insertion rate
     * @throws JAXBException of a marshalling exception occurs
     */
    protected long addUnendingPeriodic(final long streamId, final int blockSize, final int insertionRate) throws JAXBException
    {
        return addPeriodic(periodicProperties, streamId, blockSize, System.currentTimeMillis(), null, insertionRate);
    }

    /**
     * Adds a periodic through the DSS via messaging.
     *
     * @param streamId stream id
     * @param blockSize length of the data block to generate
     * @param startTime periodic start time
     * @param stopTime periodic stop time
     * @param insertionRate the periodic insertion rate
     * @throws JAXBException of a marshalling exception occurs
     */
    protected long addPeriodic(final Map<String, String> properties, final long streamId, final int blockSize, final long startTime, final Long stopTime, final int insertionRate) throws JAXBException
    {
        final byte[][] blocks = createSingleBlock(blockSize);
        final String rubyScript = JRubyBlockGenerator.generateRubyMethodForBlocks(blocks);
        return dssClient.addPeriodic(properties, streamId, rubyScript, com.ccadllc.firebird.dss.common.datatypes.MeteringType.FRONT_LOADED, new Date(startTime), (stopTime == null) ? null : new Date(stopTime), insertionRate, false);
    }

    /**
     * Adds a periodic associated with a block set through the DSS via messaging.
     *
     * @param startTime periodic start time
     * @param stopTime periodic stop time
     * @param insertionRate the periodic insertion rate
     * @param streamId stream id
     * @param blockSetId block set id to assign to the periodic.
     * @param meteringType how the periodic should be metered
     * @throws JAXBException of a marshalling exception occurs
     */
    protected long addBlockSetPeriodic(final Map<String, String> properties, final long startTime, final Long stopTime, final int insertionRate, final long streamId, final long blockSetId, final MeteringType meteringType) throws JAXBException
    {
        return dssClient.addPeriodic(properties, streamId, blockSetId, new MeteringTypeTransformer().apply(meteringType), new Date(startTime), (stopTime == null) ? null : new Date(stopTime), insertionRate, false);
    }

    /**
     * Adds a periodic associated with a data block through the DSS via messaging.
     *
     * @param streamId stream id
     * @param blockSize length of the data block to generate
     * @param insertionRate the periodic insertion rate
     * @param startTime periodic start time
     * @param stopTime periodic stop time
     * @throws JAXBException of a marshalling exception occurs
     */
    protected long addDataBlockPeriodic(final Map<String, String> properties, final long streamId, final int blockSize, final long startTime, final Long stopTime,
        final int insertionRate) throws JAXBException
    {
        return dssClient.addPeriodic(properties, streamId, createSingleBlock(blockSize), com.ccadllc.firebird.dss.common.datatypes.MeteringType.FRONT_LOADED, new Date(startTime), (stopTime == null) ? null : new Date(stopTime), insertionRate, false);
    }

    protected long createStreamAndVerifyStreamAndDestinationExistence(final Integer pid, final TransmissionType transmissionType, final StreamDestinationInfo... desintationInfos) throws Exception
    {
        final Long streamId = createStream(streamProperties, pid, transmissionType, MAX_AVERAGE, MAX_BURST, MAX_LATENCY, desintationInfos);
        verifyStreamExists(streamId);
        verifyNumberOfStreamDestinations(streamId, desintationInfos.length);
        return streamId;
    }

    protected void createStreamIllegallyAndVerifyErrorResponseIgnoringDetails(final Map<String, String> properties, final Integer pid, final TransmissionType transmissionType, final int maxAverageRate, final int maxBurstSize, final int maxShapingLatency, final String expectedErrorSummary, final StreamDestinationInfo... destinationInfos) throws Exception
    {
        final List<StreamDestinationInfo> destinationSchemas = Lists.newArrayList();
        destinationSchemas.addAll(Arrays.asList(destinationInfos));

        final CreateStandaloneStreamRequest createStreamSchema = new CreateStandaloneStreamRequest(properties, pid, destinationSchemas, transmissionType, new TrafficShapingProfile(maxAverageRate, maxBurstSize, maxShapingLatency));

        final String message = sendAndWait(asXml(createStreamSchema), CreateStandaloneStreamRequest.class.getSimpleName());
        verifyErrorResponseIgnoringDetails(message, new ErrorResponse(expectedErrorSummary));
    }

    protected void createStreamIllegallyAndVerifyErrorResponse(final Map<String, String> properties, final Integer pid, final TransmissionType transmissionType, final int maxAverageRate, final int maxBurstSize, final int maxShapingLatency, final StreamDestinationInfo... destinationInfos)
        throws Exception
    {
        final String request;
        if (!ArrayUtils.isEmpty(destinationInfos))
        {
            final List<StreamDestinationInfo> destinationSchemas = Lists.newArrayList();
            destinationSchemas.addAll(Arrays.asList(destinationInfos));

            final CreateStandaloneStreamRequest createStreamSchema = new CreateStandaloneStreamRequest(properties, pid, destinationSchemas, transmissionType, new TrafficShapingProfile(maxAverageRate, maxBurstSize, maxShapingLatency));
            request = asXml(createStreamSchema);
        }
        else
        {
            request = String
                .format(
                    "<?xml version='1.0' encoding='UTF-8' standalone='yes'?><createStandaloneStreamRequest type='%s' pid='%s'></createStandaloneStreamRequest>",
                    transmissionType, pid);
        }

        final String message = sendAndWait(request, CreateStandaloneStreamRequest.class.getSimpleName());
        verifyIsErrorResponse(message);
    }

    protected void sendIllegalAddAncillaryStreamRequestAndVerifyErrorResponse(final String illegalRequest) throws Exception
    {
        final String message = sendAndWait(illegalRequest, AddAncillaryStreamRequest.class.getSimpleName());
        verifyIsErrorResponse(message);
    }

    protected void sendIllegalAddComponentStreamRequestAndVerifyErrorResponse(final String illegalRequest) throws Exception
    {
        final String message = sendAndWait(illegalRequest, AddComponentStreamRequest.class.getSimpleName());
        verifyIsErrorResponse(message);
    }

    protected void sendIllegalCreateStreamRequestAndVerifyErrorResponse(final String illegalRequest) throws Exception
    {
        final String message = sendAndWait(illegalRequest, CreateStandaloneStreamRequest.class.getSimpleName());
        verifyIsErrorResponse(message);
    }

    protected void sendIllegalCreateShaperRequestAndVerifyErrorResponse(final String illegalRequest) throws Exception
    {
        final String message = sendAndWait(illegalRequest, CreateShaperRequest.class.getSimpleName());
        verifyIsErrorResponse(message);
    }

    protected void sendIllegalCreateMpeg2TransportStreamRequestAndVerifyErrorResponse(final String illegalRequest) throws Exception
    {
        final String message = sendAndWait(illegalRequest, CreateMpeg2TransportStreamRequest.class.getSimpleName());
        verifyIsErrorResponse(message);
    }

    protected void sendIllegalUpdateMpeg2TransportStreamDestinationsRequestAndVerifyErrorResponse(final String illegalRequest) throws Exception
    {
        final String message = sendAndWait(illegalRequest, UpdateMpeg2TransportStreamDestinationsRequest.class.getSimpleName());
        verifyIsErrorResponse(message);
    }

    protected void sendIllegalCreateIpDirectTransportStreamRequestAndVerifyErrorResponse(final String illegalRequest) throws Exception
    {
        final String message = sendAndWait(illegalRequest, CreateIpDirectTransportStreamRequest.class.getSimpleName());
        verifyIsErrorResponse(message);
    }

    protected void sendIllegalUpdateIpDirectTransportStreamDestinationsRequestAndVerifyErrorResponse(final String illegalRequest) throws Exception
    {
        final String message = sendAndWait(illegalRequest, UpdateIpDirectTransportStreamDestinationsRequest.class.getSimpleName());
        verifyIsErrorResponse(message);
    }

    protected void updateTransportStreamAndVerifyTransportStreamAndDestinationExists(final int transportStreamId, final StreamDestinationInfo... desintationInfos) throws Exception
    {
        final String request = updateMpeg2TransportStreamRequestToXml(transportStreamId, desintationInfos);
        final String response = sendAndWait(request, UpdateMpeg2TransportStreamDestinationsRequest.class.getSimpleName());

        verifyTransportStreamExists(transportStreamId);
        verifyNumberOfTransportStreamDestinations(transportStreamId, desintationInfos.length);
        for (final StreamDestinationInfo destinationInfo : desintationInfos)
        {
            verifyDestinationExistsForTransportStream(destinationInfo.getIpAddress(), destinationInfo.getPort(), transportStreamId);
        }
        verifyNotErrorResponse(response);
    }

    protected void updateStreamAndVerifyStreamAndDestinationExists(final Long streamId, final StreamDestinationInfo... desintationInfos) throws Exception
    {
        final String request = updateStreamRequestToXml(streamId, desintationInfos);
        final String response = sendAndWait(request, UpdateStandaloneStreamDestinationsRequest.class.getSimpleName());

        verifyStreamExists(streamId);
        verifyNumberOfStreamDestinations(streamId, desintationInfos.length);
        for (final StreamDestinationInfo destinationInfo : desintationInfos)
        {
            verifyDestinationExistsForStream(destinationInfo.getIpAddress(), destinationInfo.getPort(), streamId);
        }
        verifyNotErrorResponse(response);
    }

    protected void updateStreamShapingPolicyAndVerify(final Long streamId, final int maxAverageRate, final int maxBurstSize, final int maxShapingLatency) throws Exception
    {
        final String request = updateStreamShapingPolicyRequestToXml(streamId, maxAverageRate, maxBurstSize, maxShapingLatency);
        final String response = sendAndWait(request, UpdateStreamShapingPolicyRequest.class.getSimpleName());

        verifyStreamExists(streamId);
        verifyExpectedStreamShapingParameters(streamId, maxAverageRate, maxBurstSize, maxShapingLatency);
        verifyNotErrorResponse(response);
    }

    protected void updateShaperAndVerify(final Long shaperId, final int maxAverageRate, final int maxBurstSize, final int maxShapingLatency) throws Exception
    {
        final String request = updateShaperRequestToXml(shaperId, maxAverageRate, maxBurstSize, maxShapingLatency);
        final String response = sendAndWait(request, UpdateShaperRequest.class.getSimpleName());

        verifyShaperExists(shaperId, true);
        verifyNotErrorResponse(response);
    }

    protected void sendUpdateStandaloneStreamDestinationsRequestAndVerifyErrorResponse(final String request) throws Exception
    {
        final String response = sendAndWait(request, UpdateStandaloneStreamDestinationsRequest.class.getSimpleName());
        verifyIsErrorResponse(response);
    }

    protected void sendUpdateTransportStreamShapingPolicyRequestAndVerifyErrorResponse(final String request) throws Exception
    {
        final String response = sendAndWait(request, UpdateTransportStreamShapingPolicyRequest.class.getSimpleName());
        verifyIsErrorResponse(response);
    }

    protected void sendUpdateTransportStreamPropertiesRequestAndVerifyErrorResponse(final String request) throws Exception
    {
        final String response = sendAndWait(request, UpdateTransportStreamPropertiesRequest.class.getSimpleName());
        verifyIsErrorResponse(response);
    }

    protected void sendUpdateStreamShapingPolicyRequestAndVerifyErrorResponse(final String request) throws Exception
    {
        final String response = sendAndWait(request, UpdateStreamShapingPolicyRequest.class.getSimpleName());
        verifyIsErrorResponse(response);
    }

    protected void sendUpdateShaperRequestAndVerifyErrorResponse(final String request) throws Exception
    {
        final String response = sendAndWait(request, UpdateStreamShapingPolicyRequest.class.getSimpleName());
        verifyIsErrorResponse(response);
    }

    protected void sendQueryForUdpRoutesAndVefiryErrorResponse(final String request) throws Exception
    {
        final String response = sendAndWait(request, QueryForUdpRoutesRequest.class.getSimpleName());
        verifyIsErrorResponse(response);
    }

    protected void deletePeriodic(final Long periodicId) throws Exception
    {
        dssClient.deletePeriodic(periodicId);
    }

    protected void deleteShaper(final Long shaperId) throws Exception
    {
        dssClient.deleteShaper(shaperId);
    }

    protected void deleteStream(final Long streamId) throws Exception
    {
        verifyOkResponse(dssClient.deleteStream(streamId));
    }

    protected void verifyPropertiesInJmxInstrumentation(final MBeanServer mbs, final ObjectName mbeanName,
        final Map<String, String> expectedProperties) throws Exception
    {
        for (final String expectedPropertyKey : expectedProperties.keySet())
        {
            final CompositeDataSupport properties = (CompositeDataSupport)((TabularDataSupport)mbs.getAttribute(mbeanName,
                    MXBEAN_PROPERTIES_KEY)).get(new Object[] {expectedPropertyKey });
            assertThat(properties.values().size(), is(2));
            Assert.assertTrue(properties.containsValue(expectedProperties.get(expectedPropertyKey)));
        }
    }

    protected void deleteBlockSet(final long blockId) throws JAXBException
    {
        verifyOkResponse(dssClient.deleteBlockSet(blockId));
    }

    protected AddBlockSetResponse addBlockSetWithResponse(final int numberOfBlocks, final int blockSize) throws JAXBException
    {
        final String message = sendAndWait(randomAddBlockSetRequestToXml(numberOfBlocks, blockSize), AddBlockSetRequest.class.getSimpleName());
        verifyNotErrorResponse(message);
        return asMessageObject(message, AddBlockSetResponse.class);
    }

    protected String randomAddBlockSetRequestToXml(final int numberOfBlocks, final int blockSize) throws JAXBException
    {
        final List<BlockDescriptor> descriptorsSchema = Lists.newArrayList();
        descriptorsSchema.add(new BlockDescriptor(numberOfBlocks, blockSize));
        final BlockSetDescriptor descriptorSchema = new BlockSetDescriptor(descriptorsSchema);
        final AddBlockSetRequest addBlockSetRequestSchema = new AddBlockSetRequest(null, descriptorSchema);
        return asXml(addBlockSetRequestSchema);
    }

    protected void verifyBlockSetsExist(final Integer expectedNumberOfBlockSets)
    {
        final List<?> results = getJdbcTemplate() .queryForList("SELECT * FROM blockset", new Object[] {});
        assertThat(String.format("Number of block sets does not match the expected count"), results.size(), is(expectedNumberOfBlockSets));
    }

    protected boolean putBlocksetAndWait(final InputStream stream, final String url) throws IOException
    {
        for (int i = 0; i < 5; i++)
        {
            final String realUrl = String.format("http://%s:%s", "localhost", url);
            final PutMethod method = new PutMethod(realUrl);
            method.setRequestEntity(new InputStreamRequestEntity(stream));
            method.setContentChunked(true);
            try
            {
                // Using with HTTP client, as currently HTTPS is unsupported
                final HttpClient httpClient = new HttpClient();
                final int port = 8095;
                httpClient.getHostConfiguration().setHost("localhost", port);

                httpClient.executeMethod(method);
                final int responseCode = method.getStatusCode();
                if (responseCode >= 200 && responseCode < 300)
                {
                    // Return when we have successfully put the blockset on the server.
                    final Long validId = Long.parseLong(method.getResponseHeader("Block-Set-Id").getValue());
                    assertThat(validId, notNullValue());
                    return true;
                }
            }
            finally
            {
                method.releaseConnection();
            }
        }
        return false;
    }

    protected long addAndTransferBlockset(final byte[] blockSetContents, final int numberOfBlocks, final int blockSize) throws Exception
    {
        final ByteArrayInputStream inStream = new ByteArrayInputStream(blockSetContents);

        final AddBlockSetResponse response = addBlockSetWithResponse(numberOfBlocks, blockSize);
        putBlocksetAndWait(inStream, response.getUrl());
        inStream.close();
        return getBlockSetId(response);
    }

    protected void startAndWaitForBundle(final String symbolicName) throws BundleException
    {
        final Bundle bundle = getBundleReferenceBySymbolicName(symbolicName);
        bundle.start();
//        waitOnContextCreation(symbolicName);
    }

    protected void stopAndWaitForBundle(final String symbolicName) throws Exception
    {
        final Bundle bundle = getBundleReferenceBySymbolicName(symbolicName);
        bundle.stop();
//        waitForBundleShutdown(bundle);
    }

    protected Bundle getBundleReferenceBySymbolicName(final String symbolicName)
    {
        for (final Bundle bundle : bundleContext.getBundles())
        {
            if (bundle.getSymbolicName().equals(symbolicName))
            {
                return bundle;
            }
        }
        throw new IllegalStateException("Unable to get a reference to the bundle." + symbolicName);
    }

    private long getBlockSetId(final AddBlockSetResponse response)
    {
        final Matcher matcher = Pattern.compile("(\\d{1,13})(\\.block)").matcher(response.getUrl());
        matcher.find();
        return Long.parseLong(matcher.group(1));
    }

    protected long addBlockSetPeriodicAndVerifyPersited(final long streamId, final long blockSetId, final MeteringType meteringType) throws Exception
    {
        final long periodicId = addBlockSetPeriodic(periodicProperties, System.currentTimeMillis(), null, 1, streamId, blockSetId, meteringType);
        verifyPeriodicPersisted(periodicId);
        return periodicId;
    }

    protected long addFunctionPeriodicAndVerifyPersisted(final long streamId) throws Exception
    {
        final long periodicId = addUnendingPeriodic(streamId, MPEG_PACKET_PAYLOAD_SIZE_FOR_FIRST_IN_SERIES, 1);
        verifyPeriodicPersisted(periodicId);
        return periodicId;
    }

    protected long createMPEG2Stream(final int port, final String ipAddress, final Integer pid) throws Exception
    {
        return createStreamOnAddressAndPort(pid, TransmissionType.MPEG2, MAX_AVERAGE, MAX_BURST, MAX_LATENCY, ipAddress, port);
    }

    protected void verifyPacketContainsExpectedBytesOfDataInFirstMpegPacketOfDataGramPacket(final DatagramPacket packet, final int dataByteCount) throws Exception
    {
        final byte[] actualData = ArrayUtils.subarray(packet.getData(), 4, dataByteCount + 5);
        final byte[] data = new byte[dataByteCount + 1];
        Arrays.fill(data, 0, dataByteCount, TEST_BLOCK_DATA_VALUE);
        Arrays.fill(data, dataByteCount, dataByteCount + 1, (byte)0xFF);
        assertThat(actualData, is(data));
    }

    /**
     * Given a port and an array of MappingVerifiers, this method will assert that data is received from a UDP
     * source on each of the out bound destinations in the MappingVerifiers.
     *
     * Example Usage:
     *
     *   final byte[] payload = new byte[188];
     *   Arrays.fill(payload, (byte)0xFF);
     *   final MappingVerifier verifier = new MappingVerifier(payload, new MappingVerifierComposite("127.0.0.1", 1234, true));
     *   assertDataReceived(5678, verifier);
     *
     *
     * @param inPort in bound port.
     * @param verifiers array of verifiers to validate.
     * @throws Exception
     */
    protected void assertDataReceivedForUdpSource(final int inPort, final MappingVerifier... verifiers) throws Exception
    {
        int testsPassed = 0;
        int numOfDestinations = 0;

        for (final MappingVerifier pidMappingVerifier : verifiers)
        {
            numOfDestinations += pidMappingVerifier.getStreamDestinationMappingInfos().size();

            testsPassed += (dataReceivedInAllDestinationsFromUdpSource(inPort, pidMappingVerifier)).size();
        }

        assertThat(String.format("Expected %d tests to pass, %d actually passed. Please check debug log for additional information.", numOfDestinations, testsPassed), testsPassed, is(numOfDestinations));
    }

    /**
     * Given a port and an array of MappingVerifiers, this method will assert that data is received
     *  from a TCP Source on each of the out bound destinations in the MappingVerifiers.
     *
     * Example Usage:
     *
     *   final byte[] payload = new byte[188];
     *   Arrays.fill(payload, (byte)0xFF);
     *   final MappingVerifier verifier = new MappingVerifier(payload, new MappingVerifierComposite("127.0.0.1", 1234, true));
     *   assertDataReceived(5678, verifier);
     *
     *
     * @param inSocket in bound port.
     * @param verifiers array of verifiers to validate.
     * @throws Exception
     */
    protected void assertDataReceivedForTcpSource(final Socket inSocket, final MappingVerifier... verifiers) throws Exception
    {
        int testsPassed = 0;
        int numOfDestinations = 0;

        for (final MappingVerifier pidMappingVerifier : verifiers)
        {
            numOfDestinations += pidMappingVerifier.getStreamDestinationMappingInfos().size();
            testsPassed += (dataReceivedInAllDestinationsFromTcpSource(inSocket, pidMappingVerifier, true)).size();
        }
        eventBucket.clearEvent(getEventFromTopic(ROUTE_LISTENING_EVENT));

        assertThat(String.format("Expected %d tests to pass, %d actually passed. Please check debug log for additional information.", numOfDestinations, testsPassed), testsPassed, is(numOfDestinations));
    }

    protected void assertDataReceivedForTcpSourceOnAlreadyEstablishedRoute(final Socket inSocket, final MappingVerifier... verifiers) throws Exception
    {
        int testsPassed = 0;
        int numOfDestinations = 0;

        for (final MappingVerifier pidMappingVerifier : verifiers)
        {
            numOfDestinations += pidMappingVerifier.getStreamDestinationMappingInfos().size();
            testsPassed += (dataReceivedInAllDestinationsFromTcpSource(inSocket, pidMappingVerifier, false)).size();
        }

        assertThat(String.format("Expected %d tests to pass, %d actually passed. Please check debug log for additional information.", numOfDestinations, testsPassed), testsPassed, is(numOfDestinations));
    }

    /*
     * This method verifies data is received in all out bound destinations.
     *
     * A dataListenerThread is started for each destination, listening on the specified UDP port number inboundPort.
     * The origPayload (specified in  mappingVerifier) is sent to inboundPort.
     * For each destination if isMapped is true, the listener thread should receive a packet corresponding to the origPayload.
     * If isMapped is false, the listener thread should not receive the packet.
     *
     * inboundPort UDP port where the incoming packets come from.
     * pidMappingVerifier information of stream destinations to verify.
     * return list of destination index which received expected data.
     */
    protected List<Integer> dataReceivedInAllDestinationsFromTcpSource(final Socket inboundSocket, final MappingVerifier mappingVerifier, final boolean waitForEstablish) throws Exception
    {
        final List<Integer> passedStreams = Lists.newArrayList();
        final List<MappingVerifierComposite> destinationMappingInfos = mappingVerifier.getStreamDestinationMappingInfos();
        final int numOfDestinations = destinationMappingInfos.size();
        final CountDownLatch startSignal = new CountDownLatch(1);
        final CountDownLatch doneSignal = new CountDownLatch(numOfDestinations);
        final byte[] messageToSend;

        messageToSend = mappingVerifier.getOrigPayload();

        createAndStartListenerThreadsOnDestinations(passedStreams, destinationMappingInfos, numOfDestinations, startSignal, doneSignal, mappingVerifier.getOrigPayload());
        startSignal.countDown();
        if (waitForEstablish)
        {
            waitForEvent(ROUTE_LISTENING_EVENT);
        }
        inboundSocket.getOutputStream().write(messageToSend);
        doneSignal.await();
        return passedStreams;
    }

    /*
     * This method verifies data is received in all out bound destinations.
     *
     * A dataListenerThread is started for each destination, listening on the specified UDP port number inboundPort.
     * The origPayload (specified in  mappingVerifier) is sent to inboundPort.
     * For each destination if isMapped is true, the listener thread should receive a packet corresponding to the origPayload.
     * If isMapped is false, the listener thread should not receive the packet.
     *
     * inboundPort UDP port where the incoming packets come from.
     * pidMappingVerifier information of stream destinations to verify.
     * return list of destination index which received expected data.
     */
    protected List<Integer> dataReceivedInAllDestinationsFromUdpSource(final int inboundPort, final MappingVerifier mappingVerifier) throws Exception
    {
        final List<Integer> passedStreams = Lists.newArrayList();
        final List<MappingVerifierComposite> destinationMappingInfos = mappingVerifier.getStreamDestinationMappingInfos();
        final int numOfDestinations = destinationMappingInfos.size();
        final CountDownLatch startSignal = new CountDownLatch(1);
        final CountDownLatch doneSignal = new CountDownLatch(numOfDestinations);
        final byte[] udpPayload = mappingVerifier.getOrigPayload();

        createAndStartListenerThreadsOnDestinations(passedStreams, destinationMappingInfos, numOfDestinations, startSignal, doneSignal, udpPayload);

        final DatagramSocket socket = SocketUtils.openSocket();
        try
        {
            final DatagramPacket packet = new DatagramPacket(udpPayload, udpPayload.length, destinationMappingInfos.get(0).getSocketAddress().getAddress(), inboundPort);
            startSignal.countDown();
            socket.send(packet);
        }
        catch (final IOException e)
        {
            throw new RuntimeException(e);
        }
        finally
        {
            doneSignal.await();
            SocketUtils.handleSocketClose(socket);
        }
        return passedStreams;
    }

    private void createAndStartListenerThreadsOnDestinations(final List<Integer> passedStreams, final List<MappingVerifierComposite> destinationMappingInfos, final int numOfDestinations, final CountDownLatch startSignal, final CountDownLatch doneSignal, final byte[] udpPayload)
    {
        final ResultSetter setter = new ResultSetter()
        {
            @Override
            public synchronized void setResult(final boolean succeeded, final int myIndex, final String resultString)
            {
                if (succeeded)
                {
                    passedStreams.add(myIndex);
                }
                else
                {
                    logger.error(String.format("Listener thread%d %s.", myIndex, resultString));
                }
            }
        };

        for (int i = 0; i < numOfDestinations; i++)
        {
            final DataListenerThread thread = new DataListenerThread(startSignal, doneSignal, setter, destinationMappingInfos.get(i), udpPayload, i, outputHandler);
            thread.start();
        }
    }

    public interface ResultSetter
    {
        void setResult(boolean succeeded, int myIndex, String failureString);
    }

    protected byte[] getDummyMpegPacket(final int inPid)
    {
        return getDummyMpegPacket(inPid, (byte)0xC2, new byte[]{0x00, 0x00, 0x00});
    }

    protected byte[] getDummyMpegPacket(final int inPid, final byte tableId, final byte[] fillData)
    {
        // adaptation field is not set.
        final byte[] mpeg2Packet = new byte[188];
        Arrays.fill(mpeg2Packet, (byte)0xFF);
        final int startIndicatorAndPid = 0x0000FFFF & (0x00004000 | inPid);
        final byte adaptationAndContinuityCounter = 0x10;

        int mpeg2PacketIndex = 0;
        final byte[] mpeg2HeaderWithStartIndicatorSet = new byte[4];

        // Set the first four bytes for the mpeg header
        mpeg2HeaderWithStartIndicatorSet[0] = 0x47;
        mpeg2HeaderWithStartIndicatorSet[1] = (byte)(0x000000FF & (startIndicatorAndPid >> 8));
        mpeg2HeaderWithStartIndicatorSet[2] = (byte)(0x000000FF & startIndicatorAndPid);
        mpeg2HeaderWithStartIndicatorSet[3] = adaptationAndContinuityCounter;
        System.arraycopy(mpeg2HeaderWithStartIndicatorSet, 0, mpeg2Packet, mpeg2PacketIndex, mpeg2HeaderWithStartIndicatorSet.length);
        mpeg2PacketIndex = mpeg2HeaderWithStartIndicatorSet.length;
        mpeg2Packet[mpeg2PacketIndex++] = (byte)0x00;

        // set the tableid, reserved and message length bytes
        final byte msgLength = (byte)(fillData.length + 4);
        final byte[] header = new byte[] {tableId, (byte)0x30, msgLength};
        System.arraycopy(header, 0, mpeg2Packet, mpeg2PacketIndex, header.length);
        mpeg2PacketIndex += header.length;
        System.arraycopy(fillData, 0, mpeg2Packet, mpeg2PacketIndex, fillData.length);
        mpeg2PacketIndex += fillData.length;

        // calculate and set the crc at the end of the byte array
        final int crc = computeCrc(fillData);
        mpeg2Packet[mpeg2PacketIndex++] = (byte)((crc & 0xFF000000) >> 24);
        mpeg2Packet[mpeg2PacketIndex++] = (byte)((crc & 0x00FF0000) >> 16);
        mpeg2Packet[mpeg2PacketIndex++] = (byte)((crc & 0x0000FF00) >> 8);
        mpeg2Packet[mpeg2PacketIndex++] = (byte)(crc & 0x000000FF);
        Arrays.fill(mpeg2Packet, mpeg2PacketIndex, 188, (byte)0xFF);
        return mpeg2Packet;
    }

    protected byte[] getDummyMpegPacket(final int inPid, final boolean hasValidAdaptationField, final boolean hasStartIndicator)
    {
        // adaptation field is not set.
        final byte[] mpeg2Packet = new byte[188];
        Arrays.fill(mpeg2Packet, (byte)0xFF);
        final byte tableId = (byte)0xC2;
        final byte[] fillData = new byte[]{0x00, 0x00, 0x00};
        final int startIndicatorAndPid = 0x0000FFFF & (0x00004000 | inPid);
        final int noStartIndicatorAndPid = 0x0000FFFF & (0x00000000 | inPid);
        byte adaptationAndContinuityCounter;
        if (hasValidAdaptationField)
        {
            adaptationAndContinuityCounter = 0x10;
        }
        else
        {
            adaptationAndContinuityCounter = 0x00;
        }

        int mpeg2PacketIndex = 0;
        final byte[] mpeg2HeaderWithStartIndicatorSet = new byte[4];

        // Set the first four bytes for the mpeg header
        mpeg2HeaderWithStartIndicatorSet[0] = 0x47;
        if (hasStartIndicator)
        {
            mpeg2HeaderWithStartIndicatorSet[1] = (byte)(0x000000FF & (startIndicatorAndPid >> 8));
            mpeg2HeaderWithStartIndicatorSet[2] = (byte)(0x000000FF & startIndicatorAndPid);
        }
        else
        {
            mpeg2HeaderWithStartIndicatorSet[1] = (byte)(0x000000FF & (noStartIndicatorAndPid >> 8));
            mpeg2HeaderWithStartIndicatorSet[2] = (byte)(0x000000FF & noStartIndicatorAndPid);
        }
        mpeg2HeaderWithStartIndicatorSet[2] = (byte)(0x000000FF & startIndicatorAndPid);
        mpeg2HeaderWithStartIndicatorSet[3] = adaptationAndContinuityCounter;
        System.arraycopy(mpeg2HeaderWithStartIndicatorSet, 0, mpeg2Packet, mpeg2PacketIndex, mpeg2HeaderWithStartIndicatorSet.length);
        mpeg2PacketIndex = mpeg2HeaderWithStartIndicatorSet.length;
        mpeg2Packet[mpeg2PacketIndex++] = (byte)0x00;

        // set the tableid, reserved and message length bytes
        final byte msgLength = (byte)(fillData.length + 4);
        final byte[] header = new byte[] {tableId, (byte)0x30, msgLength};
        System.arraycopy(header, 0, mpeg2Packet, mpeg2PacketIndex, header.length);
        mpeg2PacketIndex += header.length;
        System.arraycopy(fillData, 0, mpeg2Packet, mpeg2PacketIndex, fillData.length);
        mpeg2PacketIndex += fillData.length;

        // calculate and set the crc at the end of the byte array
        final int crc = computeCrc(fillData);
        mpeg2Packet[mpeg2PacketIndex++] = (byte)((crc & 0xFF000000) >> 24);
        mpeg2Packet[mpeg2PacketIndex++] = (byte)((crc & 0x00FF0000) >> 16);
        mpeg2Packet[mpeg2PacketIndex++] = (byte)((crc & 0x0000FF00) >> 8);
        mpeg2Packet[mpeg2PacketIndex++] = (byte)(crc & 0x000000FF);
        Arrays.fill(mpeg2Packet, mpeg2PacketIndex, 188, (byte)0xFF);
        return mpeg2Packet;
    }

    protected int computeCrc(final byte[] value)
    {
        final Crc crc = new Crc();
        return crc.doFinal(value);
    }

    protected byte[] getDummyBlockWithHeaderData()
    {
        final byte[] data = new byte[183];
        Arrays.fill(data, (byte)0x64);
        final byte[] block = new byte[190];
        int i = 0;
        block[i++] = (byte)0x50;
        block[i++] = (byte)(5);
        block[i++] = 0;
        block[i++] = (byte)183;
        block[i++] = (byte)0x80;
        block[i++] = (byte)((VALID_PID >> 8) & 0xFF);
        block[i++] = (byte)(VALID_PID & 0xFF);

        System.arraycopy(data, 0, block, 7, 183);
        return block;
    }

    protected byte[] getTwoDummyBlocksWithHeaderData()
    {
        final byte[] data1 = new byte[8];
        Arrays.fill(data1, (byte)0x64);
        final byte[] data2 = new byte[8];
        Arrays.fill(data2, (byte)0x65);
        final byte[] block = new byte[30];
        int i = 0;
        block[i++] = (byte)0x50;
        block[i++] = (byte)(5);
        block[i++] = 0;
        block[i++] = (byte)8;
        block[i++] = (byte)0x80;
        block[i++] = (byte)((VALID_PID >> 8) & 0xFF);
        block[i++] = (byte)(VALID_PID & 0xFF);
        System.arraycopy(data1, 0, block, 7, 8);
        i += 8;

        block[i++] = (byte)0x50;
        block[i++] = (byte)(5);
        block[i++] = 0;
        block[i++] = (byte)8;
        block[i++] = (byte)0x80;
        block[i++] = (byte)(((VALID_PID  + 1) >> 8) & 0xFF);
        block[i++] = (byte)((VALID_PID + 1) & 0xFF);

        System.arraycopy(data2, 0, block, 7 + 7 + data1.length, 8);

        return block;
    }

    protected byte[] getTestBlockWithHeaderData(final byte headerType, final byte headerLength, final int dataLength, final byte flags, final Integer pid)
    {
        // Note: headerLength >= 3 if not pid, >= 5 with pid.
        final byte[] data = new byte[dataLength];
        Arrays.fill(data, (byte)0x64);
        final byte[] block = new byte[data.length + headerLength + 2];
        int i = 0;
        block[i++] = (byte)headerType;
        block[i++] = headerLength;
        block[i++] = (byte)((dataLength >> 8) & 0xFF);
        block[i++] = (byte)(dataLength & 0x00FF);
        block[i++] = flags;
        if (pid != null)
        {
            block[i++] = (byte)((pid >> 8) & 0x1F);
            block[i++] = (byte)(pid & 0xFF);
        }
        System.arraycopy(data, 0, block, 2 + headerLength, data.length);
        return block;
    }

    protected byte[] wrapAMsgSectionWithBlockHeader(final byte headerType, final byte headerLength, final byte[] msgSection, final byte flags, final Integer pid)
    {
        final int dataLength = msgSection.length;
        final byte[] block = new byte[dataLength + headerLength + 2];
        int i = 0;
        block[i++] = (byte)headerType;
        block[i++] = headerLength;
        block[i++] = (byte)((dataLength >> 8) & 0xFF);
        block[i++] = (byte)(dataLength & 0x00FF);
        block[i++] = flags;
        if (pid != null)
        {
            block[i++] = (byte)((pid >> 8) & 0x1F);
            block[i++] = (byte)(pid & 0xFF);
        }
        System.arraycopy(msgSection, 0, block, 2 + headerLength, dataLength);
        return block;
    }

    protected List<byte[]> aPat(final int transportStreamId, final List<ProgramPidMapping> pidMappings)
    {
        return psiMessageGenerator.generateProgramAssociationMessage(transportStreamId, 0, MpegCurrentNextIndicator.CURRENT, pidMappings);
    }

    protected List<byte[]> aPat(final int transportStreamId, final List<ProgramPidMapping> pidMappings, final int versionNumber)
    {
        return psiMessageGenerator.generateProgramAssociationMessage(transportStreamId, versionNumber, MpegCurrentNextIndicator.CURRENT, pidMappings);
    }

    protected List<byte[]> aPmtMessage(final int programNumber, final List<ProgramElement> components, final int version)
    {
        final List<byte[]> pmtMsgs = psiMessageGenerator.generateProgramMapMessage(
                new ProgramDefinition(version, MpegCurrentNextIndicator.CURRENT,
                        ProgramDefinition.MAX_PCR_PID, programNumber, EMPTY_MPEG_DESCRIPTOR, components));
        return pmtMsgs;
    }
    protected int establishATcpRouteWithMpegData(final Set<Long> streamIds) throws JAXBException
    {
        return dssClient.establishTcpRoute(MPEG_PACKETS, new ElementaryStreams(streamIds));
    }

    protected int establishATcpRouteWithMpegDataForTransportStreams(final Set<Integer> transportStreamIds) throws JAXBException
    {
        return dssClient.establishTcpRoute(MPEG_PACKETS, new TransportStreams(transportStreamIds));
    }

    protected long establishAUdpRouteWithMpegDataForPidMappings(final int port, final List<PidMapping> pidMappings) throws JAXBException
    {
        return dssClient.establishUdpRoute(MPEG_PACKETS, port, new PidMapped(pidMappings));
    }

    protected long establishAUdpRouteWithMpegDataForElementaryStreams(final int port, final Set<Long> streamIds) throws JAXBException
    {
        return dssClient.establishUdpRoute(MPEG_PACKETS, port, new ElementaryStreams(streamIds));
    }

    protected long establishAUdpRouteWithMpegDataForTransportStreams(final int port, final Set<Integer> transportStreamIds) throws JAXBException
    {
        return dssClient.establishUdpRoute(MPEG_PACKETS, port, new TransportStreams(transportStreamIds));
    }

    protected int establishATcpRouteWithMpegDataForPidMapped(final List<PidMapping> pidMappings) throws JAXBException
    {
        return dssClient.establishTcpRoute(MPEG_PACKETS, new PidMapped(pidMappings));
    }

    protected long establishAUdpRouteWithBlockDataForElementaryStream(final int port, final Set<Long> streamIds) throws JAXBException
    {
        return dssClient.establishUdpRoute(BLOCKS, port, new ElementaryStreams(streamIds));
    }

    protected long establishAUdpRouteWithBlockDataForTransportStream(final int port, final Set<Integer> transportStreamIds) throws JAXBException
    {
        return dssClient.establishUdpRoute(BLOCKS, port, new TransportStreams(transportStreamIds));
    }

    protected long establishAUdpRouteWithBlockDataForPidMappings(final int port, final List<PidMapping> pidMappings) throws JAXBException
    {
        return dssClient.establishUdpRoute(BLOCKS, port, new PidMapped(pidMappings));
    }

    protected int establishATcpRouteWithBlockDataToElementaryStream(final Set<Long> streamIds) throws Exception
    {
        return dssClient.establishTcpRoute(BLOCKS, new ElementaryStreams(streamIds));
    }

    protected int establishATcpRouteWithBlockDataToTransportStream(final Set<Integer> streamIds) throws Exception
    {
        return dssClient.establishTcpRoute(BLOCKS, new TransportStreams(streamIds));
    }

    protected int establishATcpRouteWithBlockDataToPidMappings(final List<PidMapping> pidMappings) throws Exception
    {
        return dssClient.establishTcpRoute(BLOCKS, new PidMapped(pidMappings));
    }

    protected void updateElementaryStreamsForRoute(final long routeId, final Set<Long> streamIds) throws JAXBException
    {
        dssClient.updateRoute(routeId, new ElementaryStreams(streamIds));
    }

    protected long establishUdpRouteWithMpegPacketRouteDataForTransportStream(final Map<String, String> properties, final Integer... transportStreamIds) throws Exception
    {
        return dssClient.establishUdpRoute(MPEG_PACKETS, properties, PORT1, new TransportStreams(Sets.newHashSet(transportStreamIds)));
    }

    protected List<UdpRouteSummary> queryForRoutesByProperties(final Map<String, String> properties) throws
    JAXBException
    {
        final String response = dssClient.queryForRoutesByProperties(properties);
        final QueryForUdpRoutesResponse actualResponse = asMessageObject(response, QueryForUdpRoutesResponse.class);
        final List<UdpRouteSummary> routes = actualResponse.getUdpRoutes();
        return routes;
    }

    protected String replaceDataInXmlElement(final String xmlToModify, final String elementName, final String value)
    {
        final String expression = "<" + elementName + ">.+</" + elementName + ">";
        return xmlToModify.replaceAll(expression, "<" + elementName + ">" + value + "</" + elementName + ">");
    }

    protected void listenForPacketsAtDestination(final Semaphore packetsReceived, final DatagramSocket anotherDatagramSocket,
        final DatagramPacket anotherPacket)
    {
        final Runnable r = new Runnable()
        {
            @Override
            public void run()
            {
                try
                {
                    outputHandler.receivePackets(anotherDatagramSocket, anotherPacket);
                    packetsReceived.release();
                }
                // CHECKSTYLE:OFF
                catch (final Exception e)
                // CHECKSTYLE:ON
                {
                    throw new RuntimeException(e);
                }
            }
        };
        new Thread(r).start();
    }
//
//    protected MpegPacketRouteData anMpegPacketRouteData(final int streamPort, final String streamAddress, final int pidNumber) throws Exception
//    {
//        final long streamId = createMPEG2Stream(streamPort, streamAddress, getNextUniqueStreamPid());
//        final PidMapping pidMapping = new PidMapping(pidNumber, Lists.newArrayList(streamId));
//        return new MpegPacketRouteData(Collections.singletonList(pidMapping));
//    }

    protected StreamSummary queryForStreamById(final long streamId) throws JAXBException
    {
        for (final StreamSummary stream : dssClient.queryForStreams(Maps.<String, String>newHashMap()))
        {
            if (stream.getId() == streamId)
            {
                return stream;
            }
        }
        return null;
    }

    protected void verifyStreamPidOutsideReservedPidRanges(final StreamSummary stream, final List<IntegerRangeSummary> reservedPidRanges)
    {
        for (final IntegerRangeSummary pidRange : reservedPidRanges)
        {
            Assert.assertFalse("Stream PID found in reserved range.", stream.getPid() >= pidRange.getBegin() && stream.getPid() <= pidRange.getEnd());
        }
    }

    protected String aValidTcpRouteRequestWithBlockData() throws JAXBException
    {
        return asXml(new EstablishRouteRequest(
                com.ccadllc.firebird.dss.common.remote.messages.RouteDataType.BLOCKS,
                new TcpRoute(new ElementaryStreams(Sets.newHashSet(123L)))));
    }

    protected String aValidUdpRouteRequestWithBlockDataAndPidMapped() throws JAXBException
    {
        return asXml(new EstablishRouteRequest(
            com.ccadllc.firebird.dss.common.remote.messages.RouteDataType.BLOCKS,
            new UdpRoute(null, PORT1, new PidMapped(Lists.newArrayList(new PidMapping(VALID_PID, Lists.newArrayList(1L)))))));
    }

    protected int aProgram(final int mpegTransportStreamId) throws JAXBException
    {
        return dssClient.addProgram(mpegTransportStreamId, 400, programProperties);
    }

    protected PidMapped aPidMappedRouteType()
    {
        final List<PidMapping> pidMapping = Lists.newArrayList();
        pidMapping.add(new PidMapping(1503, Lists.newArrayList(1L, 2L, 3L)));
        return new PidMapped(pidMapping);
    }

    protected PidMapped aPidMappedRouteTypeWthSinglePidMapping(final Integer pid, final List<Long> streamIds)
    {
        return new PidMapped(Collections.singletonList(new PidMapping(pid, streamIds)));
    }

    protected void clearExistingModelChangeEvents()
    {
        eventBucket.clearEvents();
    }

    protected void waitForEvent(final String eventName) throws Exception
    {
        waitUntil(eventBucket, new TypeSafeMatcher<EventBucket>()
        {
            @Override
            public boolean matchesSafely(final EventBucket eventBucket)
            {
                return getEventFromTopic(eventName) != null;
            }

            @Override
            public void describeTo(final Description arg0)
            {
                arg0.appendText(" catches proxies updated event ");
            }
        });
    }

    protected Event getEventFromTopic(final String eventName)
    {
        final List<Event> events = eventBucket.getEvents();
        for (final Event event : events)
        {
            if (event.toString().contains(eventName))
            {
                return event;
            }
        }
        return null;
    }

    protected void waitForConfigurationChangeEvent() throws Exception
    {
        waitUntil(eventBucket, new TypeSafeMatcher<EventBucket>()
            {
                @Override
                public boolean matchesSafely(final EventBucket eventBucket)
                {
                    final List<Event> events = eventBucket.clearEvents();

                    for (final Event event : events)
                    {
                        if (event.toString().contains(CONFIGURATION_CHANGED_EVENT))
                        {
                            return true;
                        }
                    }
                    return false;
                }

                @Override
                public void describeTo(final Description arg0)
                {
                    arg0.appendText(" catches proxies updated event ");
                }
            });
    }

    protected void verifyRouteDescriptorUnregistered(final TransportProtocolType transportProtocolType, final RouteDataType routeDataType, final RouteType routeType, final Long routeId, final int port) throws Exception
    {
        final String objectName = String.format(ROUTE_DESCRIPTOR_TEMPLATE, transportProtocolType, routeId, transportProtocolType, routeDataType, routeType, port);
        if (!verifyMBeanUnregistered(new ObjectName(objectName)))
        {
            Assert.fail(String.format("RouteDescriptor MXBean found when route was deleted, object name: %s", objectName));
        }
    }

    protected void verifyRouteDescriptorRegistered(final TransportProtocolType transportProtocolType, final RouteDataType routeDataType, final RouteType routeType, final Long routeId, final int port) throws Exception
    {
        final String objectName = String.format(ROUTE_DESCRIPTOR_TEMPLATE, transportProtocolType, routeId, transportProtocolType, routeDataType, routeType, port);
        if (verifyMBeanUnregistered(new ObjectName(objectName)))
        {
            Assert.fail(String.format("RouteDescriptor MXBean not found when route was not deleted, object name: %s", objectName));
        }
    }

    protected void verifyBlockHeaderDecoderUnregistered(final TransportProtocolType transportProtocolType, final Long routeId) throws Exception
    {
        if (!verifyMBeanUnregistered(new ObjectName(String.format(RouteJmxUtility.ROUTE_BLOCK_HEADER_DECODER_TEMPLATE, transportProtocolType, routeId))))
        {
            Assert.fail("BlockHeaderDecoder MXBean found when route was deleted.");
        }
    }

    protected void verifyBlockHeaderDecoderRegistered(final TransportProtocolType transportProtocolType, final Long routeId) throws Exception
    {
        if (verifyMBeanUnregistered(new ObjectName(String.format(RouteJmxUtility.ROUTE_BLOCK_HEADER_DECODER_TEMPLATE, transportProtocolType, routeId))))
        {
            Assert.fail("BlockHeaderDecoder MXBean not found when route was not deleted.");
        }
    }

    protected void verifyRouterUnregistered(final TransportProtocolType transportProtocolType, final RouteType routeType, final Long routeId) throws Exception
    {
        if (!verifyMBeanUnregistered(new ObjectName(String.format(RouteJmxUtility.ROUTE_PACKET_FILTER_ROUTER_TEMPLATE, transportProtocolType, routeId))))
        {
            switch (routeType)
            {
                case PID_MAPPED:
                    Assert.fail("PidMappedRouter MXBean found when route was deleted.");
                    break;
                case ELEMENTARY_STREAM:
                    Assert.fail("ElementaryStreamRouter MXBean found when route was deleted.");
                    break;
                case TRANSPORT_STREAM:
                    Assert.fail("TransportStreamRouter MXBean found when route was deleted.");
                    break;
                default:
                    Assert.fail("Invalid route type for router.");
                    break;
            }
        }
    }

    protected void verifyRouterRegistered(final TransportProtocolType transportProtocolType, final RouteType routeType, final Long routeId) throws Exception
    {
        if (verifyMBeanUnregistered(new ObjectName(String.format(RouteJmxUtility.ROUTE_PACKET_FILTER_ROUTER_TEMPLATE, transportProtocolType, routeId))))
        {
            switch (routeType)
            {
                case PID_MAPPED:
                    Assert.fail("PidMappedRouter MXBean not found when route was not deleted.");
                    break;
                case ELEMENTARY_STREAM:
                    Assert.fail("ElementaryStreamRouter MXBean not found when route was not deleted.");
                    break;
                case TRANSPORT_STREAM:
                    Assert.fail("TransportStreamRouter MXBean not found when route was not deleted.");
                    break;
                default:
                    Assert.fail("Invalid route type for router.");
                    break;
            }
        }
    }}
